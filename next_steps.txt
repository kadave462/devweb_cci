Vous allez implémenter la persistance des matchs et des équipes, puis le calcul automatique du classement.

Les étapes que vous allez devoir réaliser sont les suivantes :

Création d'un nouveau service pour interagir avec la base de données ;
Restructuration de la base de données pour stocker les équipes, les matchs et le classement ;
Utilisation de l'ORM de Spring Boot pour interagir avec la base de données ;
Mise en place de la mise à jour du classement après l'ajout d'une équipe ou d'un match ;
Alimentation de la base de données à partir des données statiques.
Vous allez devoir utiliser les concepts et technologies suivantes vus en cours :

Définir des entités avec Spring Data JPA ;
Définir des repositories avec Spring Data JPA ;
Ajouter des méthodes personnalisées aux repositories ;
Utilisation de Spring Data JPA pour effectuer des requêtes sur une base de données ;
Visualisation des requêtes SQL générées par Spring Data JPA et optimisation des requêtes.
1. Nouveau service
La structure actuelle de la base de données ne permet pas de stocker les matchs. Si nous ajoutons une table matches pour stocker les matchs, les noms des équipes seront à la fois présents dans la table ranking et dans la table matching. Cela pose un problème de redondance des données. Pour résoudre ce problème, il semble nécessaire d'ajouter une table teams pour lier les identifiants et les noms des équipes. La table ranking ne contiendra plus les noms des équipes, mais des identifiants qui correspondent à des équipes stockées dans la table teams. De même, la table matches contiendra uniquement des identifiants des équipes qui ont joué le match. Des jointures seront ensuite réalisées pour récupérer les noms des équipes.

Si la structure de la base de données évolue de cette manière, il ne semble plus pertinent d'utiliser uniquement JDBC pour interagir avec la base de données. Il semble que l'utilisation d'un ORM comme Spring Data JPA soit plus adaptée pour simplifier le développement. Cette évolution va nécessiter une modification assez conséquente de l'application. Heureusement, cette modification n'impacte que la couche d'accès aux données. Les autres composants de l'application restent inchangés.

Vérifiez que l'application actuelle utilise le service DataSoccerService. Ensuite, supprimez le service JdbcSoccerService et la classe de test associée. Lancez l'application et vérifiez qu'elle fonctionne. Créez ensuite un nouveau service nommé JpaSoccerService avec les méthodes suivantes :

@Service
public class JpaSoccerService implements SoccerService {
    private final DataSoccerService dataSoccerService;

    public JpaSoccerService(DataSoccerService dataSoccerService) {
        this.dataSoccerService = dataSoccerService;
    }

    @EventListener
    public void handleContextRefresh(ContextRefreshedEvent event) {
        fillDatabase();
    }

    public void fillDatabase() {
        if (!getRanking().isEmpty()) { return; }
        /* TODO */
    }

    @Override
    public List<RankingRowDTO> getRanking() {
        /* TODO */
        return List.of();
    }

    @Override
    public RankingRowDTO getRankingRow(UUID teamId) {
        /* TODO */
        return null;
    }

    @Override
    public List<MatchDTO> getMatches(UUID teamId) {
        /* TODO */
        return List.of();
    }
}⎘
Ajoutez également une classe de test nommée JpaSoccerServiceTest :

@SpringBootTest
@ActiveProfiles("test")
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class JpaSoccerServiceTest {
    @Autowired
    private JpaSoccerService jpaSoccerService;

    @Autowired
    private DataSoccerService dataSoccerService;
}⎘
Le nouveau service sera implémenté de façon incrémentale. Dans un premier temps, vous allez faire persister les équipes, puis les matchs. Pour finir, vous allez faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

2. Équipes
Les données statiques des équipes sont stockées dans le fichier 'src/main/resources/data/teams.json'. Il contient un tableau d'objets JSON. Chaque objet contient un identifiant et un nom d'équipe comme le record TeamDTO.

Ajoutez la méthode suivante à l'interface SoccerService :

default List<TeamDTO> getTeams() {
    return List.of();
}⎘
Dans la classe DataSoccerService, ajoutez la méthode suivante pour extraire les données du fichier teams.json :

@Override
public List<TeamDTO> getTeams() {
    return getList("teams.json", TeamDTO.class);
}⎘
En haut du script schema.sql, ajoutez la création de la table suivante :

CREATE TABLE IF NOT EXISTS teams (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);⎘
Dans la classe JpaSoccerService, ajoutez la ligne suivante dans la méthode fillDatabase (en dessous du if):

for (TeamDTO team : dataSoccerService.getTeams()) addTeam(team);⎘
Ajoutez ensuite la méthode addTeam :

public void addTeam(TeamDTO team) {
    /* TODO */
}⎘
La méthode est publique, car il est probable que cette méthode soit utilisée par la suite pour ajouter de nouvelles équipes dans la base de données. Avant d'implémenter la méthode addTeam en utilisant Spring Data JPA, vous devez créer une entité Team qui correspond à la table teams. Une entité est une classe qui est en relation avec une table dans la base de données. Dans le package com.project.entities, ajoutez la classe Team suivante :

package com.project.entities;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

@Entity
@Table(name = "teams")
public class Team {
    @Id
    public UUID id;

    @NotNull
    public String name;

    public Team() { }

    public Team(UUID id, String name) {
        this.id = id;
        this.name = name;
    }
}⎘
Une entité doit toujours avoir un constructeur sans paramètre. L'annotation @Entity indique que la classe Team est une entité. L'annotation @Table permet de spécifier le nom de la table dans la base de données. L'annotation @Id indique que l'attribut id est la clé primaire de la table. L'annotation @NotNull indique que l'attribut name ne peut pas être nul.

Ensuite, ajoutez un repository nommé TeamRepository dans le package com.project.repositories :

package com.project.repositories;

import com.project.entities.Team;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface TeamRepository extends JpaRepository<Team, UUID> { }⎘
Un repository va permettre d'effectuer des opérations en lien avec l'entité, comme ajouter, supprimer ou récupérer des entités. L'interface JpaRepository est une interface fournie par Spring Data JPA. L'annotation @Repository indique que la classe TeamRepository est un repository. Un repository peut être injecté dans un autre composant de l'application. Vous verrez par la suite qu'il est possible d'ajouter des méthodes à un repository pour effectuer des requêtes personnalisées.

Dans la classe JpaSoccerService, injectez le repository TeamRepository en ajoutant la ligne suivante et en modifiant le constructeur :

private final TeamRepository teamRepository;⎘
public JpaSoccerService(DataSoccerService dataSoccerService, TeamRepository teamRepository) {
    this.dataSoccerService = dataSoccerService;
    this.teamRepository = teamRepository;
}⎘
Dans la méthode addTeam, ajoutez le code suivant :

public void addTeam(TeamDTO team) {
    Team entity = new Team(team.id(), team.name());
    teamRepository.save(entity);
}⎘
La méthode addTeam crée une instance de l'entité Team à partir du DTO TeamDTO et l'ajoute à la base de données en utilisant le repository TeamRepository. La méthode save du repository TeamRepository permet d'ajouter une entité à la base de données. Notez que l'entité est mise à jour si elle existe déjà.

Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que les équipes sont bien ajoutées à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

Il reste à implémenter la méthode getTeams dans la classe JpaSoccerService. Ajoutez les deux méthodes suivantes à la classe JpaSoccerService :

@Override
public List<TeamDTO> getTeams() {
    return teamRepository.findAll().stream()
            .map(JpaSoccerService::toDTO)
            .toList();
}

private static TeamDTO toDTO(Team team) {
    return new TeamDTO(team.id, team.name);
}⎘
La méthode getTeams récupère toutes les équipes de la base de données en utilisant la méthode findAll du repository. Elle les convertit ensuite en DTO en utilisant la méthode toDTO. Cette conversion est effectuée grâce à la méthode map qui permet d'appliquer une fonction à chaque élément d'un stream. La notation :: permet de faire référence à une méthode. Dans notre, cas JpaSoccerService::toDTO fait référence à la méthode toDTO de la classe JpaSoccerService. La méthode map utilisera donc la méthode toDTO pour convertir chaque entité Team en un objet TeamDTO. La méthode toList permet de convertir le stream en une liste.

Vous allez maintenant ajouter un test afin de vérifier que ce que vous venez d'implémenter fonctionne correctement. Dans la classe JpaSoccerServiceTest, ajoutez le test suivant et vérifiez qu'il passe :

@Test
void testGetTeams() {
    // Given
    List<TeamDTO> expectedTeams = dataSoccerService.getTeams();
    // When
    List<TeamDTO> teams = jpaSoccerService.getTeams();
    // Then
    assertThat(teams, containsInAnyOrder(expectedTeams.toArray()));
}⎘
Les imports nécessaires pour ce test sont les suivants :

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.containsInAnyOrder;⎘
3. Matchs
Vous allez procéder de la même manière pour les matchs. Dans le fichier schema.sql, ajoutez la création de la table suivante en dessous de la création de la table teams :

CREATE TABLE IF NOT EXISTS matches (
    id UUID PRIMARY KEY,
    home_team_id UUID NOT NULL,
    away_team_id UUID NOT NULL,
    home_team_goals INTEGER NOT NULL,
    away_team_goals INTEGER NOT NULL,
    date DATE NOT NULL,
    time TIME NOT NULL,
    FOREIGN KEY (home_team_id) REFERENCES teams(id),
    FOREIGN KEY (away_team_id) REFERENCES teams(id),
    CHECK (home_team_goals >= 0 AND away_team_goals >= 0),
    CHECK (home_team_id != away_team_id),
    UNIQUE (home_team_id, away_team_id)
);⎘
Vous remarquerez que la table matches contient des identifiants d'équipes. Ces identifiants correspondent à des équipes stockées dans la table teams. Des contraintes de clés étrangères sont ajoutées pour garantir que les identifiants d'équipes stockés dans la table matches correspondent à des équipes stockées dans la table teams. Des contraintes ont été également ajoutées pour garantir que les nombres de buts sont positifs et que les équipes à domicile et à l'extérieur sont différentes. Nous avons également ajouté une contrainte d'unicité pour garantir qu'un match ne peut être joué qu'une seule fois.

Ajoutez maintenant une nouvelle entité Match dans le package com.project.entities :

package com.project.entities;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.UUID;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;

@Entity
@Table(name = "matches")
public class Match {
    @Id
    public UUID id;

    @NotNull
    @ManyToOne
    public Team homeTeam;

    @NotNull
    @ManyToOne
    public Team awayTeam;

    @NotNull
    public Integer homeTeamGoals;

    @NotNull
    public Integer awayTeamGoals;

    @NotNull
    public LocalDate date;

    @NotNull
    public  LocalTime time;

    public Match() { }

    public Match(UUID id, Team homeTeam, Team awayTeam,
                 Integer homeTeamGoals, Integer awayTeamGoals,
                 LocalDate date, LocalTime time) {
        this.id = id;
        this.homeTeam = homeTeam;
        this.awayTeam = awayTeam;
        this.homeTeamGoals = homeTeamGoals;
        this.awayTeamGoals = awayTeamGoals;
        this.date = date;
        this.time = time;
    }
}⎘
La nouveauté ici est l'utilisation de l'annotation @ManyToOne pour les attributs homeTeam et awayTeam. Cette annotation permet de spécifier une relation entre deux entités. Dans notre cas, un match a une équipe à domicile et une équipe à l'extérieur. L'annotation @ManyToOne indique que l'attribut homeTeam est une relation many-to-one avec l'entité Team. Cela signifie qu'une équipe peut jouer plusieurs matchs, mais qu'un match ne peut avoir qu'une seule équipe à domicile et une seule équipe à l'extérieur. Il existe d'autres annotations pour spécifier d'autres types de relations, comme @OneToMany, @OneToOne ou @ManyToMany. Vous remarquerez que le type des attributs homeTeam et awayTeam est Team et non UUID. En effet, l'annotation @ManyToOne permet de récupérer directement l'entité Team à partir de l'identifiant de l'équipe. Cela permet de simplifier les requêtes SQL et de récupérer directement les entités liées. La colonne de nom home_team_id (resp. away_team_id) dans la table matches est automatiquement liée à l'attribut homeTeam (resp. awayTeam) de l'entité Match. Ces liens sont réalisés grâce aux annotations et aux conventions de nommage.

Ajoutez un repository nommé MatchRepository dans le package com.project.repositories :

package com.project.repositories;

import com.project.entities.Match;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface MatchRepository extends JpaRepository<Match, UUID> { }⎘
Comme pour ajouter un match, il n'est pas nécessaire de connaître les noms des équipes qui participent au match, vous allez définir un nouveau DTO pour fournir les informations nécessaires à la création d'un match. Ajoutez la classe MatchCreationDTO suivante dans le package com.project.dtos :

public record MatchCreationDTO(
    UUID id,
    UUID homeTeamId,
    UUID awayTeamId,
    Integer homeTeamGoals,
    Integer awayTeamGoals,
    LocalDate date,
    LocalTime time
) {
}⎘
À la fin de la méthode fillDatabase de la classe JpaSoccerService, ajoutez la ligne suivante :

for (MatchDTO match : dataSoccerService.getMatches()) {
    addMatch(new MatchCreationDTO(
            match.id(),
            match.homeTeam().id(), match.awayTeam().id(),
            match.homeTeamGoals(), match.awayTeamGoals(),
            match.date(), match.time()));
}⎘
Ajoutez ensuite la méthode addMatch :

public void addMatch(MatchCreationDTO match) {
    /* TODO */
}⎘
Injectez le repository MatchRepository dans la classe JpaSoccerService et essayez d'implémenter la méthode addMatch en utilisant Spring Data JPA. Pour créer l'entité, vous devez récupérer les entités Team correspondant aux équipes à domicile et à l'extérieur. Pour cela, vous pouvez utiliser la méthode findById du repository TeamRepository de la façon suivante :

Team homeTeam = teamRepository.findById(match.homeTeamId()).orElseThrow();⎘
La méthode findById est une méthode de l'interface JpaRepository qui permet de récupérer une entité à partir de son identifiant. Cette méthode retourne un Optional qui contient l'entité si elle existe. La méthode orElseThrow permet de lancer une exception si l'équipe n'existe pas, c'est-à-dire, si l'Optional est vide. Une fois l'instance de la classe Match créée, vous devez la sauvegarder dans repository MatchRepository en utilisant la méthode save. Exécutez l'application et vérifiez que les matchs sont bien ajoutés à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

Il reste à implémenter la méthode getMatches dans la classe JpaSoccerService. Cette méthode doit retourner les matchs joués par une équipe. Les matchs doivent être triés par date et heure. Pour cela, ajoutez une nouvelle méthode dans le repository MatchRepository :

List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
Cette méthode permet de récupérer tous les matchs joués par une équipe à domicile ou à l'extérieur. Les matchs sont triés par date et heure. Notez que, si vous souhaitez récupérer la liste des matchs joués par une équipe d'identifiant teamId, il suffit d'appeler cette méthode de la façon suivante :

List<Match> matches = matchRepository.findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(teamId, teamId);⎘
Ajoutez la méthode suivante à la classe JpaSoccerService et complétez-la. Elle a pour but de convertir une entité Match en DTO MatchDTO.

private static MatchDTO toDTO(Match match) {
    return new MatchDTO(/* TODO */);
}⎘
Vous remarquerez qu'il est possible de récupérer l'identifiant et le nom des équipes à domicile et à l'extérieur en utilisant les attributs homeTeam et awayTeam de l'entité Match. Complétez ensuite la méthode getMatches en utilisant les méthodes précédemment définies.

Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifier qu'il passe :

@Test
void testGetMatches() {
    // Given
    List<TeamDTO> teams = dataSoccerService.getTeams();
    UUID teamId = teams.get(4).id();
    List<MatchDTO> expectedMatches = dataSoccerService.getMatches(teamId);
    // When
    List<MatchDTO> matches = jpaSoccerService.getMatches(teamId);
    // Then
    assertEquals(expectedMatches, matches);
}⎘
4. Calcul du classement
Vous allez maintenant faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

Dans un premier temps, vous allez modifier la création de la table ranking afin de supprimer le nom de l'équipe et d'ajouter la contrainte de clé étrangère. Modifiez la création de la table dans le script schema.sql de la façon suivante :

CREATE TABLE IF NOT EXISTS ranking (
    team_id UUID PRIMARY KEY,
    rank INTEGER NOT NULL,
    match_played_count INTEGER NOT NULL,
    match_won_count INTEGER NOT NULL,
    match_lost_count INTEGER NOT NULL,
    draw_count INTEGER NOT NULL,
    goal_for_count INTEGER NOT NULL,
    goal_against_count INTEGER NOT NULL,
    goal_difference INTEGER NOT NULL,
    points INTEGER NOT NULL,
    FOREIGN KEY (team_id) REFERENCES teams(id)
);⎘
Vous allez ensuite ajouter la nouvelle entité RankingRow suivante :

@Entity
@Table(name = "ranking")
public class RankingRow {
    @Id
    public UUID teamId;

    @OneToOne
    @MapsId
    public Team team;

    public int rank;
    public int matchPlayedCount;
    public int matchWonCount;
    public int matchLostCount;
    public int drawCount;
    public int goalForCount;
    public int goalAgainstCount;
    public int goalDifference;
    public int points;

    public RankingRow() {}

    public RankingRow(Team team, int rank, int matchPlayedCount, int matchWonCount,
                      int matchLostCount, int drawCount, int goalForCount,
                      int goalAgainstCount, int goalDifference, int points) {
        this.teamId = team.id;
        this.team = team;
        this.rank = rank;
        this.matchPlayedCount = matchPlayedCount;
        this.matchWonCount = matchWonCount;
        this.matchLostCount = matchLostCount;
        this.drawCount = drawCount;
        this.goalForCount = goalForCount;
        this.goalAgainstCount = goalAgainstCount;
        this.goalDifference = goalDifference;
        this.points = points;
    }
}⎘
Une entité doit nécessairement avoir un identifiant. Il est donc nécessaire de définir l'attribut teamId et de l'annoter avec @Id. L'attribut team est nécessaire pour avoir accédé au nom de l'équipe. Il est annoté avec @OneToOne pour spécifier une relation one-to-one avec l'entité Team. L'annotation @MapsId permet de lier l'identifiant de RankingRow et l'identifiant utilisé pour la relation one-to-one.

Ajoutez maintenant le repository RankingRepository dans le package com.project.repositories :

@Repository
public interface RankingRepository extends JpaRepository<RankingRow, UUID> {
}⎘
Dans la classe JpaSoccerService, injectez le repository RankingRepository en ajoutant la ligne suivante et en modifiant le constructeur :

private final RankingRepository rankingRepository;⎘
public JpaSoccerService(DataSoccerService dataSoccerService,
                TeamRepository teamRepository,
                MatchRepository matchRepository,
                RankingRepository rankingRepository) {
    this.dataSoccerService = dataSoccerService;
    this.teamRepository = teamRepository;
    this.matchRepository = matchRepository;
    this.rankingRepository = rankingRepository;
}⎘
Au moment de l'ajout d'une équipe, vous allez devoir ajouter une ligne vide au classement. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser cette opération :

private void addEmptyRankingRow(Team team) {
    RankingRow entity = new RankingRow(team, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    rankingRepository.save(entity);
}⎘
Modifiez la méthode addTeam pour qu'elle ajoute une ligne vide au classement associée à l'équipe ajoutée.

Au moment de l'ajout d'un match, vous devez mettre à jour les deux lignes du classement correspondant aux équipes qui ont joué le match. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser la mise à jour d'une ligne du classement à partir de l'identifiant de l'équipe, du nombre de buts qu'elle a marqués et du nombre de buts qu'elle a encaissés :

private void updateRankingRow(UUID teamId, int goalsForCount, int goalsAgainstCount) {
    RankingRow entity = rankingRepository.findById(teamId).orElseThrow();
    boolean win = goalsForCount > goalsAgainstCount;
    boolean draw = goalsForCount == goalsAgainstCount;
    boolean loss = goalsForCount < goalsAgainstCount;
    entity.matchPlayedCount++;
    entity.matchWonCount += win ? 1 : 0;
    entity.drawCount += draw ? 1 : 0;
    entity.matchLostCount += loss ? 1 : 0;
    entity.goalForCount += goalsForCount;
    entity.goalAgainstCount += goalsAgainstCount;
    entity.goalDifference += goalsForCount - goalsAgainstCount;
    entity.points += win ? 3 : draw ? 1 : 0;
    rankingRepository.save(entity);
}⎘
Modifiez ensuite la méthode addMatch pour qu'elle mette à jour les lignes du classement correspondant aux équipes qui ont joué le match. Pour cela, ajoutez les deux lignes suivantes à la fin de la méthode addMatch :

updateRankingRow(match.homeTeamId(), match.homeTeamGoals(), match.awayTeamGoals());
updateRankingRow(match.awayTeamId(), match.awayTeamGoals(), match.homeTeamGoals());⎘
Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que le classement est calculé en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console. Vous remarquerez que la colonne rank contient toujours des zéros, car nous n'avons pas encore fait en sorte qu'il soit recalculé après la modification du classement.

Ajoutez la méthode suivante dans le repository RankingRepository :

List<RankingRow> findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc();⎘
Cette méthode permet d'obtenir les lignes du classement dans l'ordre du classement, c'est-à-dire, triées par points, différence de buts et nombre de buts marqués.

Ajoutez ensuite la méthode suivante dans la classe JpaSoccerService pour recalculer le rang de chaque équipe :

private void updateRanks() {
    int rank = 1;
    for (RankingRow row : rankingRepository.findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc()) {
        row.rank = rank;
        rankingRepository.save(row);
        rank++;
    }
}⎘
Cette méthode récupère toutes les lignes du classement triées par points, différence de buts et nombre de buts marqués. Elle met à jour le rang de chaque équipe en fonction de son classement. La méthode save du repository RankingRepository permet de mettre à jour la ligne du classement dans la base de données. Faites en sorte que la méthode updateRanks soit appelée après l'ajout d'une équipe ou d'un match. Supprimez une nouvelle fois la base de données, relancez l'application et vérifiez que les rangs des équipes ont été calculés.

Il reste à implémenter les deux méthodes getRanking et getRankingRow dans la classe JpaSoccerService. Ajoutez la méthode suivante au repository RankingRepository de façon à obtenir le classement trié par rang :

List<RankingRow> findAllByOrderByRankAsc();⎘
Ensuite, ajoutez la méthode suivante à la classe JpaSoccerService pour convertir les entités en DTO et complétez-la :

private static RankingRowDTO toDTO(RankingRow rankingRow) {
    return new RankingRowDTO(/* TODO */);
}⎘
Utilisez les méthodes définies précédemment pour implémenter la méthode getRanking. Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifiez qu'il passe :

@Test
void testGetRanking() {
    // Given
    List<RankingRowDTO> expectedRanking = dataSoccerService.getRanking();
    // When
    List<RankingRowDTO> ranking = jpaSoccerService.getRanking();
    // Then
    assertEquals(expectedRanking, ranking);
}⎘
L'alimentation actuelle de la base de données ne remplit plus directement la table ranking avec les informations du fichier ranking.json. Le contenu de la table est calculé à partir des équipes et des matchs. Le test vérifie que le classement présent dans la table ranking après l'alimentation de la base de données est égal au classement contenu dans le fichier ranking.json.

Implémentez maintenant la méthode getRankingRow comme ceci :

@Override
public RankingRowDTO getRankingRow(UUID teamId) {
    return rankingRepository.findById(teamId)
            .map(JpaSoccerService::toDTO)
            .orElseThrow();
}⎘
Ajoutez ensuite le test suivant et vérifiez qu'il passe :

@Test
void testGetRankingRow() {
    // Given
    List<TeamDTO> teams = dataSoccerService.getTeams();
    UUID teamId = teams.get(4).id();
    RankingRowDTO expectedRankingRow = dataSoccerService.getRankingRow(teamId);
    // When
    RankingRowDTO rankingRow = jpaSoccerService.getRankingRow(teamId);
    // Then
    assertEquals(expectedRankingRow, rankingRow);
}⎘
Faites en sorte que le service JpaSoccerService soit utilisé par l'application en ajoutant l'annotation @Primary à la classe JpaSoccerService et en la supprimant à la classe DataSoccerService. Supprimez la base de données, puis lancez l'application et vérifiez qu'elle fonctionne correctement.

5. Transactions
Les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService effectuent plusieurs opérations sur la base de données. Il est important que ces opérations soient effectuées de manière atomique. Pour cela, vous allez utiliser des transactions. Une transaction est un ensemble d'opérations effectuées de manière atomique. Si une des opérations échoue, toutes les opérations effectuées dans la transaction sont annulées. De plus, les requêtes ne pourront jamais voir les modifications effectuées durant la transaction tant que celle-ci n'est pas validée, c'est-à-dire, complètement réalisée.

Dans le cas de Spring Data JPA, l'annotation @Transactional permet de spécifier que la méthode doit être exécutée dans une transaction. Ajoutez l'annotation @Transactional(isolation = Isolation.SERIALIZABLE) devant les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService. Relancez l'application et vérifiez qu'elle fonctionne correctement.

Le paramètre isolation permet de spécifier le niveau d'isolation de la transaction. Le niveau d'isolation SERIALIZABLE est le plus élevé. Normalement, ce niveau permet de simuler une exécution sérielle des transactions validées, comme si elles avaient été exécutées les unes après les autres séquentiellement. Le niveau d'isolation par défaut généralement est READ_COMMITTED. Avec ce niveau, les requêtes SELECT d'une transaction peuvent voir les données qui ont été commitées par les autres transactions. Ce niveau d'isolation n'est pas suffisant pour notre application. Par exemple, lors de l'ajout de deux matchs simultanément, il est possible que le classement ne soit pas mis à jour correctement. En effet, une même ligne peut être récupérée par deux transactions simultanées, puis mise à jour. Dans ce cas, la première transaction écrasera les modifications de la seconde transaction. Notez que la mise à jour des rangs peut également poser problème. Notez qu'en production, il est nécessaire d'utiliser un autre SGBD que H2 pour garantir la cohérence des données. H2 est un SGBD embarqué qui ne garantit pas une implémentation complète du niveau d'isolation SERIALIZABLE. Par conséquent, il est possible que des problèmes de concurrence surviennent lors de l'exécution de l'application.

6. Optimisation des requêtes
Cette section est facultative. Si vous n'avez pas le temps de la faire, vous pouvez passer directement au prochain TD. N'oubliez pas de commiter et de pusher votre code vers votre dépôt distant avant de passer au prochain TD.

Vous allez faire en sorte de pouvoir visualiser les requêtes effectuées par l'application. Pour cela, replacez le contenu du fichier application.yml par le contenu suivant :

server:
  error:
    include-stacktrace: always
    include-message: always
spring:
  datasource:
    url: jdbc:h2:file:./database
    driverClassName: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
  jpa:
    show-sql: true
  sql:
    init:
      mode: always⎘
Nous avons positionné la propriété spring.jpa.show-sql à true pour afficher les requêtes SQL effectuées par l'application. Lancez l'application et regardez les requêtes qui sont effectuées par l'application.

Affichez le classement des équipes en utilisant l'application. Vous remarquerez qu'une première requête est effectuée pour récupérer le contenu de la table ranking. Ensuite, 20 requêtes sont effectuées sur la table teams pour récupérer le nom de l'équipe. Ces requêtes sont effectuées pour peupler les attributs team des entités RankingRow avec les noms des équipes. Ce problème est appelé le problème du n+1 selects.

Pour éviter cela, il faudrait que la première requête contienne une jointure vers la table teams. Avec JPA, il est possible de préciser les requêtes qui seront effectuées par les appels aux méthodes des repositories en utilisant l'annotation @Query. Cette annotation permet de spécifier la requête SQL qui sera effectuée par la méthode. Plus précisément, vous devez fournir une requête JPQL (Java Persistence Query Language) qui est un langage de requête orienté objet. Par exemple, il est possible d'annoter la méthode findAllByOrderByRankAsc du repository RankingRepository avec l'annotation suivante :

@Query("SELECT r FROM RankingRow r JOIN FETCH r.team ORDER BY r.rank ASC")
List<RankingRow> findAllByOrderByRankAsc();⎘
Cette solution fonctionne, mais elle n'est pas optimale, car il est nécessaire d'écrire une requête JPQL dans le code de l'application. On perd l'avantage de Spring Data JPA qui permet de générer automatiquement les requêtes SQL à partir des noms des méthodes.

Une autre solution consiste à utiliser des annotations @EntityGraph pour spécifier les entités qui doivent être chargées en même temps que l'entité principale. Par exemple, pour charger les noms des équipes en même temps que les lignes du classement, il est possible d'ajouter l'annotation @EntityGraph à la méthode du repository comme ceci :

@EntityGraph(attributePaths = {"team"})
List<RankingRow> findAllByOrderByRankAsc();⎘
Essayez d'ajouter cette annotation à la méthode findAllByOrderByRankAsc du repository RankingRepository. Relancez l'application et regardez les requêtes qui sont effectuées par l'application. Vous remarquerez que les noms des équipes sont maintenant récupérés en une seule requête.

Quand la page de l'équipe est affichée, un appel à la méthode findById du repository RankingRepository est effectué pour récupérer la ligne du classement correspondant à l'équipe. Cette méthode est définie dans l'interface JpaRepository. Vous allez la redéfinir pour qu'elle effectue une jointure de la façon suivante :

@EntityGraph(attributePaths = {"team"})
@NonNull Optional<RankingRow> findById(@NonNull UUID teamId);⎘
Regardez les requêtes qui sont effectuées au moment du chargement de la page d'une équipe. Le chargement des matchs nécessite actuellement de nombreuses requêtes pour obtenir les noms des équipes qui participent aux matchs. Pour corriger cela, dans le repository MatchRepository, ajoutez une annotation @EntityGraph à la méthode findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc pour récupérer les noms des équipes en même temps que les matchs :

@EntityGraph(attributePaths = {"homeTeam", "awayTeam"})
List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
Relancez l'application et regardez à nouveau les requêtes qui sont effectuées par l'application. Le chargement du classement doit nécessiter une seule requête et le chargement de la page d'une équipe doit nécessiter deux requêtes : une pour récupérer la ligne du classement et une autre pour récupérer les matchs.

Quand vous utilisez un ORM, il est toujours important de visualiser les requêtes qui sont effectuées par votre application. Cela permet de s'assurer que les requêtes sont optimales et de détecter les éventuels problèmes de performance.

N'oubliez pas de faire un commit et de le pousser sur le dépôt distant.Vous allez implémenter la persistance des matchs et des équipes, puis le calcul automatique du classement.

                                                                       Les étapes que vous allez devoir réaliser sont les suivantes :

                                                                       Création d'un nouveau service pour interagir avec la base de données ;
                                                                       Restructuration de la base de données pour stocker les équipes, les matchs et le classement ;
                                                                       Utilisation de l'ORM de Spring Boot pour interagir avec la base de données ;
                                                                       Mise en place de la mise à jour du classement après l'ajout d'une équipe ou d'un match ;
                                                                       Alimentation de la base de données à partir des données statiques.
                                                                       Vous allez devoir utiliser les concepts et technologies suivantes vus en cours :

                                                                       Définir des entités avec Spring Data JPA ;
                                                                       Définir des repositories avec Spring Data JPA ;
                                                                       Ajouter des méthodes personnalisées aux repositories ;
                                                                       Utilisation de Spring Data JPA pour effectuer des requêtes sur une base de données ;
                                                                       Visualisation des requêtes SQL générées par Spring Data JPA et optimisation des requêtes.
                                                                       1. Nouveau service
                                                                       La structure actuelle de la base de données ne permet pas de stocker les matchs. Si nous ajoutons une table matches pour stocker les matchs, les noms des équipes seront à la fois présents dans la table ranking et dans la table matching. Cela pose un problème de redondance des données. Pour résoudre ce problème, il semble nécessaire d'ajouter une table teams pour lier les identifiants et les noms des équipes. La table ranking ne contiendra plus les noms des équipes, mais des identifiants qui correspondent à des équipes stockées dans la table teams. De même, la table matches contiendra uniquement des identifiants des équipes qui ont joué le match. Des jointures seront ensuite réalisées pour récupérer les noms des équipes.

                                                                       Si la structure de la base de données évolue de cette manière, il ne semble plus pertinent d'utiliser uniquement JDBC pour interagir avec la base de données. Il semble que l'utilisation d'un ORM comme Spring Data JPA soit plus adaptée pour simplifier le développement. Cette évolution va nécessiter une modification assez conséquente de l'application. Heureusement, cette modification n'impacte que la couche d'accès aux données. Les autres composants de l'application restent inchangés.

                                                                       Vérifiez que l'application actuelle utilise le service DataSoccerService. Ensuite, supprimez le service JdbcSoccerService et la classe de test associée. Lancez l'application et vérifiez qu'elle fonctionne. Créez ensuite un nouveau service nommé JpaSoccerService avec les méthodes suivantes :

                                                                       @Service
                                                                       public class JpaSoccerService implements SoccerService {
                                                                           private final DataSoccerService dataSoccerService;

                                                                           public JpaSoccerService(DataSoccerService dataSoccerService) {
                                                                               this.dataSoccerService = dataSoccerService;
                                                                           }

                                                                           @EventListener
                                                                           public void handleContextRefresh(ContextRefreshedEvent event) {
                                                                               fillDatabase();
                                                                           }

                                                                           public void fillDatabase() {
                                                                               if (!getRanking().isEmpty()) { return; }
                                                                               /* TODO */
                                                                           }

                                                                           @Override
                                                                           public List<RankingRowDTO> getRanking() {
                                                                               /* TODO */
                                                                               return List.of();
                                                                           }

                                                                           @Override
                                                                           public RankingRowDTO getRankingRow(UUID teamId) {
                                                                               /* TODO */
                                                                               return null;
                                                                           }

                                                                           @Override
                                                                           public List<MatchDTO> getMatches(UUID teamId) {
                                                                               /* TODO */
                                                                               return List.of();
                                                                           }
                                                                       }⎘
                                                                       Ajoutez également une classe de test nommée JpaSoccerServiceTest :

                                                                       @SpringBootTest
                                                                       @ActiveProfiles("test")
                                                                       @DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
                                                                       public class JpaSoccerServiceTest {
                                                                           @Autowired
                                                                           private JpaSoccerService jpaSoccerService;

                                                                           @Autowired
                                                                           private DataSoccerService dataSoccerService;
                                                                       }⎘
                                                                       Le nouveau service sera implémenté de façon incrémentale. Dans un premier temps, vous allez faire persister les équipes, puis les matchs. Pour finir, vous allez faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                       2. Équipes
                                                                       Les données statiques des équipes sont stockées dans le fichier 'src/main/resources/data/teams.json'. Il contient un tableau d'objets JSON. Chaque objet contient un identifiant et un nom d'équipe comme le record TeamDTO.

                                                                       Ajoutez la méthode suivante à l'interface SoccerService :

                                                                       default List<TeamDTO> getTeams() {
                                                                           return List.of();
                                                                       }⎘
                                                                       Dans la classe DataSoccerService, ajoutez la méthode suivante pour extraire les données du fichier teams.json :

                                                                       @Override
                                                                       public List<TeamDTO> getTeams() {
                                                                           return getList("teams.json", TeamDTO.class);
                                                                       }⎘
                                                                       En haut du script schema.sql, ajoutez la création de la table suivante :

                                                                       CREATE TABLE IF NOT EXISTS teams (
                                                                           id UUID PRIMARY KEY,
                                                                           name VARCHAR(255) NOT NULL
                                                                       );⎘
                                                                       Dans la classe JpaSoccerService, ajoutez la ligne suivante dans la méthode fillDatabase (en dessous du if):

                                                                       for (TeamDTO team : dataSoccerService.getTeams()) addTeam(team);⎘
                                                                       Ajoutez ensuite la méthode addTeam :

                                                                       public void addTeam(TeamDTO team) {
                                                                           /* TODO */
                                                                       }⎘
                                                                       La méthode est publique, car il est probable que cette méthode soit utilisée par la suite pour ajouter de nouvelles équipes dans la base de données. Avant d'implémenter la méthode addTeam en utilisant Spring Data JPA, vous devez créer une entité Team qui correspond à la table teams. Une entité est une classe qui est en relation avec une table dans la base de données. Dans le package com.project.entities, ajoutez la classe Team suivante :

                                                                       package com.project.entities;

                                                                       import jakarta.persistence.Entity;
                                                                       import jakarta.persistence.Table;
                                                                       import jakarta.persistence.Id;
                                                                       import jakarta.validation.constraints.NotNull;
                                                                       import java.util.UUID;

                                                                       @Entity
                                                                       @Table(name = "teams")
                                                                       public class Team {
                                                                           @Id
                                                                           public UUID id;

                                                                           @NotNull
                                                                           public String name;

                                                                           public Team() { }

                                                                           public Team(UUID id, String name) {
                                                                               this.id = id;
                                                                               this.name = name;
                                                                           }
                                                                       }⎘
                                                                       Une entité doit toujours avoir un constructeur sans paramètre. L'annotation @Entity indique que la classe Team est une entité. L'annotation @Table permet de spécifier le nom de la table dans la base de données. L'annotation @Id indique que l'attribut id est la clé primaire de la table. L'annotation @NotNull indique que l'attribut name ne peut pas être nul.

                                                                       Ensuite, ajoutez un repository nommé TeamRepository dans le package com.project.repositories :

                                                                       package com.project.repositories;

                                                                       import com.project.entities.Team;
                                                                       import org.springframework.data.jpa.repository.JpaRepository;
                                                                       import org.springframework.stereotype.Repository;
                                                                       import java.util.UUID;

                                                                       @Repository
                                                                       public interface TeamRepository extends JpaRepository<Team, UUID> { }⎘
                                                                       Un repository va permettre d'effectuer des opérations en lien avec l'entité, comme ajouter, supprimer ou récupérer des entités. L'interface JpaRepository est une interface fournie par Spring Data JPA. L'annotation @Repository indique que la classe TeamRepository est un repository. Un repository peut être injecté dans un autre composant de l'application. Vous verrez par la suite qu'il est possible d'ajouter des méthodes à un repository pour effectuer des requêtes personnalisées.

                                                                       Dans la classe JpaSoccerService, injectez le repository TeamRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                       private final TeamRepository teamRepository;⎘
                                                                       public JpaSoccerService(DataSoccerService dataSoccerService, TeamRepository teamRepository) {
                                                                           this.dataSoccerService = dataSoccerService;
                                                                           this.teamRepository = teamRepository;
                                                                       }⎘
                                                                       Dans la méthode addTeam, ajoutez le code suivant :

                                                                       public void addTeam(TeamDTO team) {
                                                                           Team entity = new Team(team.id(), team.name());
                                                                           teamRepository.save(entity);
                                                                       }⎘
                                                                       La méthode addTeam crée une instance de l'entité Team à partir du DTO TeamDTO et l'ajoute à la base de données en utilisant le repository TeamRepository. La méthode save du repository TeamRepository permet d'ajouter une entité à la base de données. Notez que l'entité est mise à jour si elle existe déjà.

                                                                       Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que les équipes sont bien ajoutées à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                       Il reste à implémenter la méthode getTeams dans la classe JpaSoccerService. Ajoutez les deux méthodes suivantes à la classe JpaSoccerService :

                                                                       @Override
                                                                       public List<TeamDTO> getTeams() {
                                                                           return teamRepository.findAll().stream()
                                                                                   .map(JpaSoccerService::toDTO)
                                                                                   .toList();
                                                                       }

                                                                       private static TeamDTO toDTO(Team team) {
                                                                           return new TeamDTO(team.id, team.name);
                                                                       }⎘
                                                                       La méthode getTeams récupère toutes les équipes de la base de données en utilisant la méthode findAll du repository. Elle les convertit ensuite en DTO en utilisant la méthode toDTO. Cette conversion est effectuée grâce à la méthode map qui permet d'appliquer une fonction à chaque élément d'un stream. La notation :: permet de faire référence à une méthode. Dans notre, cas JpaSoccerService::toDTO fait référence à la méthode toDTO de la classe JpaSoccerService. La méthode map utilisera donc la méthode toDTO pour convertir chaque entité Team en un objet TeamDTO. La méthode toList permet de convertir le stream en une liste.

                                                                       Vous allez maintenant ajouter un test afin de vérifier que ce que vous venez d'implémenter fonctionne correctement. Dans la classe JpaSoccerServiceTest, ajoutez le test suivant et vérifiez qu'il passe :

                                                                       @Test
                                                                       void testGetTeams() {
                                                                           // Given
                                                                           List<TeamDTO> expectedTeams = dataSoccerService.getTeams();
                                                                           // When
                                                                           List<TeamDTO> teams = jpaSoccerService.getTeams();
                                                                           // Then
                                                                           assertThat(teams, containsInAnyOrder(expectedTeams.toArray()));
                                                                       }⎘
                                                                       Les imports nécessaires pour ce test sont les suivants :

                                                                       import static org.hamcrest.MatcherAssert.assertThat;
                                                                       import static org.hamcrest.Matchers.containsInAnyOrder;⎘
                                                                       3. Matchs
                                                                       Vous allez procéder de la même manière pour les matchs. Dans le fichier schema.sql, ajoutez la création de la table suivante en dessous de la création de la table teams :

                                                                       CREATE TABLE IF NOT EXISTS matches (
                                                                           id UUID PRIMARY KEY,
                                                                           home_team_id UUID NOT NULL,
                                                                           away_team_id UUID NOT NULL,
                                                                           home_team_goals INTEGER NOT NULL,
                                                                           away_team_goals INTEGER NOT NULL,
                                                                           date DATE NOT NULL,
                                                                           time TIME NOT NULL,
                                                                           FOREIGN KEY (home_team_id) REFERENCES teams(id),
                                                                           FOREIGN KEY (away_team_id) REFERENCES teams(id),
                                                                           CHECK (home_team_goals >= 0 AND away_team_goals >= 0),
                                                                           CHECK (home_team_id != away_team_id),
                                                                           UNIQUE (home_team_id, away_team_id)
                                                                       );⎘
                                                                       Vous remarquerez que la table matches contient des identifiants d'équipes. Ces identifiants correspondent à des équipes stockées dans la table teams. Des contraintes de clés étrangères sont ajoutées pour garantir que les identifiants d'équipes stockés dans la table matches correspondent à des équipes stockées dans la table teams. Des contraintes ont été également ajoutées pour garantir que les nombres de buts sont positifs et que les équipes à domicile et à l'extérieur sont différentes. Nous avons également ajouté une contrainte d'unicité pour garantir qu'un match ne peut être joué qu'une seule fois.

                                                                       Ajoutez maintenant une nouvelle entité Match dans le package com.project.entities :

                                                                       package com.project.entities;

                                                                       import java.time.LocalDate;
                                                                       import java.time.LocalTime;
                                                                       import java.util.UUID;

                                                                       import jakarta.persistence.Entity;
                                                                       import jakarta.persistence.Id;
                                                                       import jakarta.persistence.ManyToOne;
                                                                       import jakarta.persistence.Table;
                                                                       import jakarta.validation.constraints.NotNull;

                                                                       @Entity
                                                                       @Table(name = "matches")
                                                                       public class Match {
                                                                           @Id
                                                                           public UUID id;

                                                                           @NotNull
                                                                           @ManyToOne
                                                                           public Team homeTeam;

                                                                           @NotNull
                                                                           @ManyToOne
                                                                           public Team awayTeam;

                                                                           @NotNull
                                                                           public Integer homeTeamGoals;

                                                                           @NotNull
                                                                           public Integer awayTeamGoals;

                                                                           @NotNull
                                                                           public LocalDate date;

                                                                           @NotNull
                                                                           public  LocalTime time;

                                                                           public Match() { }

                                                                           public Match(UUID id, Team homeTeam, Team awayTeam,
                                                                                        Integer homeTeamGoals, Integer awayTeamGoals,
                                                                                        LocalDate date, LocalTime time) {
                                                                               this.id = id;
                                                                               this.homeTeam = homeTeam;
                                                                               this.awayTeam = awayTeam;
                                                                               this.homeTeamGoals = homeTeamGoals;
                                                                               this.awayTeamGoals = awayTeamGoals;
                                                                               this.date = date;
                                                                               this.time = time;
                                                                           }
                                                                       }⎘
                                                                       La nouveauté ici est l'utilisation de l'annotation @ManyToOne pour les attributs homeTeam et awayTeam. Cette annotation permet de spécifier une relation entre deux entités. Dans notre cas, un match a une équipe à domicile et une équipe à l'extérieur. L'annotation @ManyToOne indique que l'attribut homeTeam est une relation many-to-one avec l'entité Team. Cela signifie qu'une équipe peut jouer plusieurs matchs, mais qu'un match ne peut avoir qu'une seule équipe à domicile et une seule équipe à l'extérieur. Il existe d'autres annotations pour spécifier d'autres types de relations, comme @OneToMany, @OneToOne ou @ManyToMany. Vous remarquerez que le type des attributs homeTeam et awayTeam est Team et non UUID. En effet, l'annotation @ManyToOne permet de récupérer directement l'entité Team à partir de l'identifiant de l'équipe. Cela permet de simplifier les requêtes SQL et de récupérer directement les entités liées. La colonne de nom home_team_id (resp. away_team_id) dans la table matches est automatiquement liée à l'attribut homeTeam (resp. awayTeam) de l'entité Match. Ces liens sont réalisés grâce aux annotations et aux conventions de nommage.

                                                                       Ajoutez un repository nommé MatchRepository dans le package com.project.repositories :

                                                                       package com.project.repositories;

                                                                       import com.project.entities.Match;
                                                                       import org.springframework.data.jpa.repository.JpaRepository;
                                                                       import org.springframework.stereotype.Repository;
                                                                       import java.util.UUID;

                                                                       @Repository
                                                                       public interface MatchRepository extends JpaRepository<Match, UUID> { }⎘
                                                                       Comme pour ajouter un match, il n'est pas nécessaire de connaître les noms des équipes qui participent au match, vous allez définir un nouveau DTO pour fournir les informations nécessaires à la création d'un match. Ajoutez la classe MatchCreationDTO suivante dans le package com.project.dtos :

                                                                       public record MatchCreationDTO(
                                                                           UUID id,
                                                                           UUID homeTeamId,
                                                                           UUID awayTeamId,
                                                                           Integer homeTeamGoals,
                                                                           Integer awayTeamGoals,
                                                                           LocalDate date,
                                                                           LocalTime time
                                                                       ) {
                                                                       }⎘
                                                                       À la fin de la méthode fillDatabase de la classe JpaSoccerService, ajoutez la ligne suivante :

                                                                       for (MatchDTO match : dataSoccerService.getMatches()) {
                                                                           addMatch(new MatchCreationDTO(
                                                                                   match.id(),
                                                                                   match.homeTeam().id(), match.awayTeam().id(),
                                                                                   match.homeTeamGoals(), match.awayTeamGoals(),
                                                                                   match.date(), match.time()));
                                                                       }⎘
                                                                       Ajoutez ensuite la méthode addMatch :

                                                                       public void addMatch(MatchCreationDTO match) {
                                                                           /* TODO */
                                                                       }⎘
                                                                       Injectez le repository MatchRepository dans la classe JpaSoccerService et essayez d'implémenter la méthode addMatch en utilisant Spring Data JPA. Pour créer l'entité, vous devez récupérer les entités Team correspondant aux équipes à domicile et à l'extérieur. Pour cela, vous pouvez utiliser la méthode findById du repository TeamRepository de la façon suivante :

                                                                       Team homeTeam = teamRepository.findById(match.homeTeamId()).orElseThrow();⎘
                                                                       La méthode findById est une méthode de l'interface JpaRepository qui permet de récupérer une entité à partir de son identifiant. Cette méthode retourne un Optional qui contient l'entité si elle existe. La méthode orElseThrow permet de lancer une exception si l'équipe n'existe pas, c'est-à-dire, si l'Optional est vide. Une fois l'instance de la classe Match créée, vous devez la sauvegarder dans repository MatchRepository en utilisant la méthode save. Exécutez l'application et vérifiez que les matchs sont bien ajoutés à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                       Il reste à implémenter la méthode getMatches dans la classe JpaSoccerService. Cette méthode doit retourner les matchs joués par une équipe. Les matchs doivent être triés par date et heure. Pour cela, ajoutez une nouvelle méthode dans le repository MatchRepository :

                                                                       List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                       Cette méthode permet de récupérer tous les matchs joués par une équipe à domicile ou à l'extérieur. Les matchs sont triés par date et heure. Notez que, si vous souhaitez récupérer la liste des matchs joués par une équipe d'identifiant teamId, il suffit d'appeler cette méthode de la façon suivante :

                                                                       List<Match> matches = matchRepository.findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(teamId, teamId);⎘
                                                                       Ajoutez la méthode suivante à la classe JpaSoccerService et complétez-la. Elle a pour but de convertir une entité Match en DTO MatchDTO.

                                                                       private static MatchDTO toDTO(Match match) {
                                                                           return new MatchDTO(/* TODO */);
                                                                       }⎘
                                                                       Vous remarquerez qu'il est possible de récupérer l'identifiant et le nom des équipes à domicile et à l'extérieur en utilisant les attributs homeTeam et awayTeam de l'entité Match. Complétez ensuite la méthode getMatches en utilisant les méthodes précédemment définies.

                                                                       Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifier qu'il passe :

                                                                       @Test
                                                                       void testGetMatches() {
                                                                           // Given
                                                                           List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                           UUID teamId = teams.get(4).id();
                                                                           List<MatchDTO> expectedMatches = dataSoccerService.getMatches(teamId);
                                                                           // When
                                                                           List<MatchDTO> matches = jpaSoccerService.getMatches(teamId);
                                                                           // Then
                                                                           assertEquals(expectedMatches, matches);
                                                                       }⎘
                                                                       4. Calcul du classement
                                                                       Vous allez maintenant faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                       Dans un premier temps, vous allez modifier la création de la table ranking afin de supprimer le nom de l'équipe et d'ajouter la contrainte de clé étrangère. Modifiez la création de la table dans le script schema.sql de la façon suivante :

                                                                       CREATE TABLE IF NOT EXISTS ranking (
                                                                           team_id UUID PRIMARY KEY,
                                                                           rank INTEGER NOT NULL,
                                                                           match_played_count INTEGER NOT NULL,
                                                                           match_won_count INTEGER NOT NULL,
                                                                           match_lost_count INTEGER NOT NULL,
                                                                           draw_count INTEGER NOT NULL,
                                                                           goal_for_count INTEGER NOT NULL,
                                                                           goal_against_count INTEGER NOT NULL,
                                                                           goal_difference INTEGER NOT NULL,
                                                                           points INTEGER NOT NULL,
                                                                           FOREIGN KEY (team_id) REFERENCES teams(id)
                                                                       );⎘
                                                                       Vous allez ensuite ajouter la nouvelle entité RankingRow suivante :

                                                                       @Entity
                                                                       @Table(name = "ranking")
                                                                       public class RankingRow {
                                                                           @Id
                                                                           public UUID teamId;

                                                                           @OneToOne
                                                                           @MapsId
                                                                           public Team team;

                                                                           public int rank;
                                                                           public int matchPlayedCount;
                                                                           public int matchWonCount;
                                                                           public int matchLostCount;
                                                                           public int drawCount;
                                                                           public int goalForCount;
                                                                           public int goalAgainstCount;
                                                                           public int goalDifference;
                                                                           public int points;

                                                                           public RankingRow() {}

                                                                           public RankingRow(Team team, int rank, int matchPlayedCount, int matchWonCount,
                                                                                             int matchLostCount, int drawCount, int goalForCount,
                                                                                             int goalAgainstCount, int goalDifference, int points) {
                                                                               this.teamId = team.id;
                                                                               this.team = team;
                                                                               this.rank = rank;
                                                                               this.matchPlayedCount = matchPlayedCount;
                                                                               this.matchWonCount = matchWonCount;
                                                                               this.matchLostCount = matchLostCount;
                                                                               this.drawCount = drawCount;
                                                                               this.goalForCount = goalForCount;
                                                                               this.goalAgainstCount = goalAgainstCount;
                                                                               this.goalDifference = goalDifference;
                                                                               this.points = points;
                                                                           }
                                                                       }⎘
                                                                       Une entité doit nécessairement avoir un identifiant. Il est donc nécessaire de définir l'attribut teamId et de l'annoter avec @Id. L'attribut team est nécessaire pour avoir accédé au nom de l'équipe. Il est annoté avec @OneToOne pour spécifier une relation one-to-one avec l'entité Team. L'annotation @MapsId permet de lier l'identifiant de RankingRow et l'identifiant utilisé pour la relation one-to-one.

                                                                       Ajoutez maintenant le repository RankingRepository dans le package com.project.repositories :

                                                                       @Repository
                                                                       public interface RankingRepository extends JpaRepository<RankingRow, UUID> {
                                                                       }⎘
                                                                       Dans la classe JpaSoccerService, injectez le repository RankingRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                       private final RankingRepository rankingRepository;⎘
                                                                       public JpaSoccerService(DataSoccerService dataSoccerService,
                                                                                       TeamRepository teamRepository,
                                                                                       MatchRepository matchRepository,
                                                                                       RankingRepository rankingRepository) {
                                                                           this.dataSoccerService = dataSoccerService;
                                                                           this.teamRepository = teamRepository;
                                                                           this.matchRepository = matchRepository;
                                                                           this.rankingRepository = rankingRepository;
                                                                       }⎘
                                                                       Au moment de l'ajout d'une équipe, vous allez devoir ajouter une ligne vide au classement. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser cette opération :

                                                                       private void addEmptyRankingRow(Team team) {
                                                                           RankingRow entity = new RankingRow(team, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                                                                           rankingRepository.save(entity);
                                                                       }⎘
                                                                       Modifiez la méthode addTeam pour qu'elle ajoute une ligne vide au classement associée à l'équipe ajoutée.

                                                                       Au moment de l'ajout d'un match, vous devez mettre à jour les deux lignes du classement correspondant aux équipes qui ont joué le match. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser la mise à jour d'une ligne du classement à partir de l'identifiant de l'équipe, du nombre de buts qu'elle a marqués et du nombre de buts qu'elle a encaissés :

                                                                       private void updateRankingRow(UUID teamId, int goalsForCount, int goalsAgainstCount) {
                                                                           RankingRow entity = rankingRepository.findById(teamId).orElseThrow();
                                                                           boolean win = goalsForCount > goalsAgainstCount;
                                                                           boolean draw = goalsForCount == goalsAgainstCount;
                                                                           boolean loss = goalsForCount < goalsAgainstCount;
                                                                           entity.matchPlayedCount++;
                                                                           entity.matchWonCount += win ? 1 : 0;
                                                                           entity.drawCount += draw ? 1 : 0;
                                                                           entity.matchLostCount += loss ? 1 : 0;
                                                                           entity.goalForCount += goalsForCount;
                                                                           entity.goalAgainstCount += goalsAgainstCount;
                                                                           entity.goalDifference += goalsForCount - goalsAgainstCount;
                                                                           entity.points += win ? 3 : draw ? 1 : 0;
                                                                           rankingRepository.save(entity);
                                                                       }⎘
                                                                       Modifiez ensuite la méthode addMatch pour qu'elle mette à jour les lignes du classement correspondant aux équipes qui ont joué le match. Pour cela, ajoutez les deux lignes suivantes à la fin de la méthode addMatch :

                                                                       updateRankingRow(match.homeTeamId(), match.homeTeamGoals(), match.awayTeamGoals());
                                                                       updateRankingRow(match.awayTeamId(), match.awayTeamGoals(), match.homeTeamGoals());⎘
                                                                       Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que le classement est calculé en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console. Vous remarquerez que la colonne rank contient toujours des zéros, car nous n'avons pas encore fait en sorte qu'il soit recalculé après la modification du classement.

                                                                       Ajoutez la méthode suivante dans le repository RankingRepository :

                                                                       List<RankingRow> findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc();⎘
                                                                       Cette méthode permet d'obtenir les lignes du classement dans l'ordre du classement, c'est-à-dire, triées par points, différence de buts et nombre de buts marqués.

                                                                       Ajoutez ensuite la méthode suivante dans la classe JpaSoccerService pour recalculer le rang de chaque équipe :

                                                                       private void updateRanks() {
                                                                           int rank = 1;
                                                                           for (RankingRow row : rankingRepository.findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc()) {
                                                                               row.rank = rank;
                                                                               rankingRepository.save(row);
                                                                               rank++;
                                                                           }
                                                                       }⎘
                                                                       Cette méthode récupère toutes les lignes du classement triées par points, différence de buts et nombre de buts marqués. Elle met à jour le rang de chaque équipe en fonction de son classement. La méthode save du repository RankingRepository permet de mettre à jour la ligne du classement dans la base de données. Faites en sorte que la méthode updateRanks soit appelée après l'ajout d'une équipe ou d'un match. Supprimez une nouvelle fois la base de données, relancez l'application et vérifiez que les rangs des équipes ont été calculés.

                                                                       Il reste à implémenter les deux méthodes getRanking et getRankingRow dans la classe JpaSoccerService. Ajoutez la méthode suivante au repository RankingRepository de façon à obtenir le classement trié par rang :

                                                                       List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                       Ensuite, ajoutez la méthode suivante à la classe JpaSoccerService pour convertir les entités en DTO et complétez-la :

                                                                       private static RankingRowDTO toDTO(RankingRow rankingRow) {
                                                                           return new RankingRowDTO(/* TODO */);
                                                                       }⎘
                                                                       Utilisez les méthodes définies précédemment pour implémenter la méthode getRanking. Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifiez qu'il passe :

                                                                       @Test
                                                                       void testGetRanking() {
                                                                           // Given
                                                                           List<RankingRowDTO> expectedRanking = dataSoccerService.getRanking();
                                                                           // When
                                                                           List<RankingRowDTO> ranking = jpaSoccerService.getRanking();
                                                                           // Then
                                                                           assertEquals(expectedRanking, ranking);
                                                                       }⎘
                                                                       L'alimentation actuelle de la base de données ne remplit plus directement la table ranking avec les informations du fichier ranking.json. Le contenu de la table est calculé à partir des équipes et des matchs. Le test vérifie que le classement présent dans la table ranking après l'alimentation de la base de données est égal au classement contenu dans le fichier ranking.json.

                                                                       Implémentez maintenant la méthode getRankingRow comme ceci :

                                                                       @Override
                                                                       public RankingRowDTO getRankingRow(UUID teamId) {
                                                                           return rankingRepository.findById(teamId)
                                                                                   .map(JpaSoccerService::toDTO)
                                                                                   .orElseThrow();
                                                                       }⎘
                                                                       Ajoutez ensuite le test suivant et vérifiez qu'il passe :

                                                                       @Test
                                                                       void testGetRankingRow() {
                                                                           // Given
                                                                           List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                           UUID teamId = teams.get(4).id();
                                                                           RankingRowDTO expectedRankingRow = dataSoccerService.getRankingRow(teamId);
                                                                           // When
                                                                           RankingRowDTO rankingRow = jpaSoccerService.getRankingRow(teamId);
                                                                           // Then
                                                                           assertEquals(expectedRankingRow, rankingRow);
                                                                       }⎘
                                                                       Faites en sorte que le service JpaSoccerService soit utilisé par l'application en ajoutant l'annotation @Primary à la classe JpaSoccerService et en la supprimant à la classe DataSoccerService. Supprimez la base de données, puis lancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                       5. Transactions
                                                                       Les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService effectuent plusieurs opérations sur la base de données. Il est important que ces opérations soient effectuées de manière atomique. Pour cela, vous allez utiliser des transactions. Une transaction est un ensemble d'opérations effectuées de manière atomique. Si une des opérations échoue, toutes les opérations effectuées dans la transaction sont annulées. De plus, les requêtes ne pourront jamais voir les modifications effectuées durant la transaction tant que celle-ci n'est pas validée, c'est-à-dire, complètement réalisée.

                                                                       Dans le cas de Spring Data JPA, l'annotation @Transactional permet de spécifier que la méthode doit être exécutée dans une transaction. Ajoutez l'annotation @Transactional(isolation = Isolation.SERIALIZABLE) devant les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService. Relancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                       Le paramètre isolation permet de spécifier le niveau d'isolation de la transaction. Le niveau d'isolation SERIALIZABLE est le plus élevé. Normalement, ce niveau permet de simuler une exécution sérielle des transactions validées, comme si elles avaient été exécutées les unes après les autres séquentiellement. Le niveau d'isolation par défaut généralement est READ_COMMITTED. Avec ce niveau, les requêtes SELECT d'une transaction peuvent voir les données qui ont été commitées par les autres transactions. Ce niveau d'isolation n'est pas suffisant pour notre application. Par exemple, lors de l'ajout de deux matchs simultanément, il est possible que le classement ne soit pas mis à jour correctement. En effet, une même ligne peut être récupérée par deux transactions simultanées, puis mise à jour. Dans ce cas, la première transaction écrasera les modifications de la seconde transaction. Notez que la mise à jour des rangs peut également poser problème. Notez qu'en production, il est nécessaire d'utiliser un autre SGBD que H2 pour garantir la cohérence des données. H2 est un SGBD embarqué qui ne garantit pas une implémentation complète du niveau d'isolation SERIALIZABLE. Par conséquent, il est possible que des problèmes de concurrence surviennent lors de l'exécution de l'application.

                                                                       6. Optimisation des requêtes
                                                                       Cette section est facultative. Si vous n'avez pas le temps de la faire, vous pouvez passer directement au prochain TD. N'oubliez pas de commiter et de pusher votre code vers votre dépôt distant avant de passer au prochain TD.

                                                                       Vous allez faire en sorte de pouvoir visualiser les requêtes effectuées par l'application. Pour cela, replacez le contenu du fichier application.yml par le contenu suivant :

                                                                       server:
                                                                         error:
                                                                           include-stacktrace: always
                                                                           include-message: always
                                                                       spring:
                                                                         datasource:
                                                                           url: jdbc:h2:file:./database
                                                                           driverClassName: org.h2.Driver
                                                                           username: sa
                                                                           password:
                                                                         h2:
                                                                           console:
                                                                             enabled: true
                                                                         jpa:
                                                                           show-sql: true
                                                                         sql:
                                                                           init:
                                                                             mode: always⎘
                                                                       Nous avons positionné la propriété spring.jpa.show-sql à true pour afficher les requêtes SQL effectuées par l'application. Lancez l'application et regardez les requêtes qui sont effectuées par l'application.

                                                                       Affichez le classement des équipes en utilisant l'application. Vous remarquerez qu'une première requête est effectuée pour récupérer le contenu de la table ranking. Ensuite, 20 requêtes sont effectuées sur la table teams pour récupérer le nom de l'équipe. Ces requêtes sont effectuées pour peupler les attributs team des entités RankingRow avec les noms des équipes. Ce problème est appelé le problème du n+1 selects.

                                                                       Pour éviter cela, il faudrait que la première requête contienne une jointure vers la table teams. Avec JPA, il est possible de préciser les requêtes qui seront effectuées par les appels aux méthodes des repositories en utilisant l'annotation @Query. Cette annotation permet de spécifier la requête SQL qui sera effectuée par la méthode. Plus précisément, vous devez fournir une requête JPQL (Java Persistence Query Language) qui est un langage de requête orienté objet. Par exemple, il est possible d'annoter la méthode findAllByOrderByRankAsc du repository RankingRepository avec l'annotation suivante :

                                                                       @Query("SELECT r FROM RankingRow r JOIN FETCH r.team ORDER BY r.rank ASC")
                                                                       List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                       Cette solution fonctionne, mais elle n'est pas optimale, car il est nécessaire d'écrire une requête JPQL dans le code de l'application. On perd l'avantage de Spring Data JPA qui permet de générer automatiquement les requêtes SQL à partir des noms des méthodes.

                                                                       Une autre solution consiste à utiliser des annotations @EntityGraph pour spécifier les entités qui doivent être chargées en même temps que l'entité principale. Par exemple, pour charger les noms des équipes en même temps que les lignes du classement, il est possible d'ajouter l'annotation @EntityGraph à la méthode du repository comme ceci :

                                                                       @EntityGraph(attributePaths = {"team"})
                                                                       List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                       Essayez d'ajouter cette annotation à la méthode findAllByOrderByRankAsc du repository RankingRepository. Relancez l'application et regardez les requêtes qui sont effectuées par l'application. Vous remarquerez que les noms des équipes sont maintenant récupérés en une seule requête.

                                                                       Quand la page de l'équipe est affichée, un appel à la méthode findById du repository RankingRepository est effectué pour récupérer la ligne du classement correspondant à l'équipe. Cette méthode est définie dans l'interface JpaRepository. Vous allez la redéfinir pour qu'elle effectue une jointure de la façon suivante :

                                                                       @EntityGraph(attributePaths = {"team"})
                                                                       @NonNull Optional<RankingRow> findById(@NonNull UUID teamId);⎘
                                                                       Regardez les requêtes qui sont effectuées au moment du chargement de la page d'une équipe. Le chargement des matchs nécessite actuellement de nombreuses requêtes pour obtenir les noms des équipes qui participent aux matchs. Pour corriger cela, dans le repository MatchRepository, ajoutez une annotation @EntityGraph à la méthode findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc pour récupérer les noms des équipes en même temps que les matchs :

                                                                       @EntityGraph(attributePaths = {"homeTeam", "awayTeam"})
                                                                       List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                       Relancez l'application et regardez à nouveau les requêtes qui sont effectuées par l'application. Le chargement du classement doit nécessiter une seule requête et le chargement de la page d'une équipe doit nécessiter deux requêtes : une pour récupérer la ligne du classement et une autre pour récupérer les matchs.

                                                                       Quand vous utilisez un ORM, il est toujours important de visualiser les requêtes qui sont effectuées par votre application. Cela permet de s'assurer que les requêtes sont optimales et de détecter les éventuels problèmes de performance.

                                                                       N'oubliez pas de faire un commit et de le pousser sur le dépôt distant.Vous allez implémenter la persistance des matchs et des équipes, puis le calcul automatique du classement.

                                                                                                                                              Les étapes que vous allez devoir réaliser sont les suivantes :

                                                                                                                                              Création d'un nouveau service pour interagir avec la base de données ;
                                                                                                                                              Restructuration de la base de données pour stocker les équipes, les matchs et le classement ;
                                                                                                                                              Utilisation de l'ORM de Spring Boot pour interagir avec la base de données ;
                                                                                                                                              Mise en place de la mise à jour du classement après l'ajout d'une équipe ou d'un match ;
                                                                                                                                              Alimentation de la base de données à partir des données statiques.
                                                                                                                                              Vous allez devoir utiliser les concepts et technologies suivantes vus en cours :

                                                                                                                                              Définir des entités avec Spring Data JPA ;
                                                                                                                                              Définir des repositories avec Spring Data JPA ;
                                                                                                                                              Ajouter des méthodes personnalisées aux repositories ;
                                                                                                                                              Utilisation de Spring Data JPA pour effectuer des requêtes sur une base de données ;
                                                                                                                                              Visualisation des requêtes SQL générées par Spring Data JPA et optimisation des requêtes.
                                                                                                                                              1. Nouveau service
                                                                                                                                              La structure actuelle de la base de données ne permet pas de stocker les matchs. Si nous ajoutons une table matches pour stocker les matchs, les noms des équipes seront à la fois présents dans la table ranking et dans la table matching. Cela pose un problème de redondance des données. Pour résoudre ce problème, il semble nécessaire d'ajouter une table teams pour lier les identifiants et les noms des équipes. La table ranking ne contiendra plus les noms des équipes, mais des identifiants qui correspondent à des équipes stockées dans la table teams. De même, la table matches contiendra uniquement des identifiants des équipes qui ont joué le match. Des jointures seront ensuite réalisées pour récupérer les noms des équipes.

                                                                                                                                              Si la structure de la base de données évolue de cette manière, il ne semble plus pertinent d'utiliser uniquement JDBC pour interagir avec la base de données. Il semble que l'utilisation d'un ORM comme Spring Data JPA soit plus adaptée pour simplifier le développement. Cette évolution va nécessiter une modification assez conséquente de l'application. Heureusement, cette modification n'impacte que la couche d'accès aux données. Les autres composants de l'application restent inchangés.

                                                                                                                                              Vérifiez que l'application actuelle utilise le service DataSoccerService. Ensuite, supprimez le service JdbcSoccerService et la classe de test associée. Lancez l'application et vérifiez qu'elle fonctionne. Créez ensuite un nouveau service nommé JpaSoccerService avec les méthodes suivantes :

                                                                                                                                              @Service
                                                                                                                                              public class JpaSoccerService implements SoccerService {
                                                                                                                                                  private final DataSoccerService dataSoccerService;

                                                                                                                                                  public JpaSoccerService(DataSoccerService dataSoccerService) {
                                                                                                                                                      this.dataSoccerService = dataSoccerService;
                                                                                                                                                  }

                                                                                                                                                  @EventListener
                                                                                                                                                  public void handleContextRefresh(ContextRefreshedEvent event) {
                                                                                                                                                      fillDatabase();
                                                                                                                                                  }

                                                                                                                                                  public void fillDatabase() {
                                                                                                                                                      if (!getRanking().isEmpty()) { return; }
                                                                                                                                                      /* TODO */
                                                                                                                                                  }

                                                                                                                                                  @Override
                                                                                                                                                  public List<RankingRowDTO> getRanking() {
                                                                                                                                                      /* TODO */
                                                                                                                                                      return List.of();
                                                                                                                                                  }

                                                                                                                                                  @Override
                                                                                                                                                  public RankingRowDTO getRankingRow(UUID teamId) {
                                                                                                                                                      /* TODO */
                                                                                                                                                      return null;
                                                                                                                                                  }

                                                                                                                                                  @Override
                                                                                                                                                  public List<MatchDTO> getMatches(UUID teamId) {
                                                                                                                                                      /* TODO */
                                                                                                                                                      return List.of();
                                                                                                                                                  }
                                                                                                                                              }⎘
                                                                                                                                              Ajoutez également une classe de test nommée JpaSoccerServiceTest :

                                                                                                                                              @SpringBootTest
                                                                                                                                              @ActiveProfiles("test")
                                                                                                                                              @DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
                                                                                                                                              public class JpaSoccerServiceTest {
                                                                                                                                                  @Autowired
                                                                                                                                                  private JpaSoccerService jpaSoccerService;

                                                                                                                                                  @Autowired
                                                                                                                                                  private DataSoccerService dataSoccerService;
                                                                                                                                              }⎘
                                                                                                                                              Le nouveau service sera implémenté de façon incrémentale. Dans un premier temps, vous allez faire persister les équipes, puis les matchs. Pour finir, vous allez faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                                                                                              2. Équipes
                                                                                                                                              Les données statiques des équipes sont stockées dans le fichier 'src/main/resources/data/teams.json'. Il contient un tableau d'objets JSON. Chaque objet contient un identifiant et un nom d'équipe comme le record TeamDTO.

                                                                                                                                              Ajoutez la méthode suivante à l'interface SoccerService :

                                                                                                                                              default List<TeamDTO> getTeams() {
                                                                                                                                                  return List.of();
                                                                                                                                              }⎘
                                                                                                                                              Dans la classe DataSoccerService, ajoutez la méthode suivante pour extraire les données du fichier teams.json :

                                                                                                                                              @Override
                                                                                                                                              public List<TeamDTO> getTeams() {
                                                                                                                                                  return getList("teams.json", TeamDTO.class);
                                                                                                                                              }⎘
                                                                                                                                              En haut du script schema.sql, ajoutez la création de la table suivante :

                                                                                                                                              CREATE TABLE IF NOT EXISTS teams (
                                                                                                                                                  id UUID PRIMARY KEY,
                                                                                                                                                  name VARCHAR(255) NOT NULL
                                                                                                                                              );⎘
                                                                                                                                              Dans la classe JpaSoccerService, ajoutez la ligne suivante dans la méthode fillDatabase (en dessous du if):

                                                                                                                                              for (TeamDTO team : dataSoccerService.getTeams()) addTeam(team);⎘
                                                                                                                                              Ajoutez ensuite la méthode addTeam :

                                                                                                                                              public void addTeam(TeamDTO team) {
                                                                                                                                                  /* TODO */
                                                                                                                                              }⎘
                                                                                                                                              La méthode est publique, car il est probable que cette méthode soit utilisée par la suite pour ajouter de nouvelles équipes dans la base de données. Avant d'implémenter la méthode addTeam en utilisant Spring Data JPA, vous devez créer une entité Team qui correspond à la table teams. Une entité est une classe qui est en relation avec une table dans la base de données. Dans le package com.project.entities, ajoutez la classe Team suivante :

                                                                                                                                              package com.project.entities;

                                                                                                                                              import jakarta.persistence.Entity;
                                                                                                                                              import jakarta.persistence.Table;
                                                                                                                                              import jakarta.persistence.Id;
                                                                                                                                              import jakarta.validation.constraints.NotNull;
                                                                                                                                              import java.util.UUID;

                                                                                                                                              @Entity
                                                                                                                                              @Table(name = "teams")
                                                                                                                                              public class Team {
                                                                                                                                                  @Id
                                                                                                                                                  public UUID id;

                                                                                                                                                  @NotNull
                                                                                                                                                  public String name;

                                                                                                                                                  public Team() { }

                                                                                                                                                  public Team(UUID id, String name) {
                                                                                                                                                      this.id = id;
                                                                                                                                                      this.name = name;
                                                                                                                                                  }
                                                                                                                                              }⎘
                                                                                                                                              Une entité doit toujours avoir un constructeur sans paramètre. L'annotation @Entity indique que la classe Team est une entité. L'annotation @Table permet de spécifier le nom de la table dans la base de données. L'annotation @Id indique que l'attribut id est la clé primaire de la table. L'annotation @NotNull indique que l'attribut name ne peut pas être nul.

                                                                                                                                              Ensuite, ajoutez un repository nommé TeamRepository dans le package com.project.repositories :

                                                                                                                                              package com.project.repositories;

                                                                                                                                              import com.project.entities.Team;
                                                                                                                                              import org.springframework.data.jpa.repository.JpaRepository;
                                                                                                                                              import org.springframework.stereotype.Repository;
                                                                                                                                              import java.util.UUID;

                                                                                                                                              @Repository
                                                                                                                                              public interface TeamRepository extends JpaRepository<Team, UUID> { }⎘
                                                                                                                                              Un repository va permettre d'effectuer des opérations en lien avec l'entité, comme ajouter, supprimer ou récupérer des entités. L'interface JpaRepository est une interface fournie par Spring Data JPA. L'annotation @Repository indique que la classe TeamRepository est un repository. Un repository peut être injecté dans un autre composant de l'application. Vous verrez par la suite qu'il est possible d'ajouter des méthodes à un repository pour effectuer des requêtes personnalisées.

                                                                                                                                              Dans la classe JpaSoccerService, injectez le repository TeamRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                                                                                              private final TeamRepository teamRepository;⎘
                                                                                                                                              public JpaSoccerService(DataSoccerService dataSoccerService, TeamRepository teamRepository) {
                                                                                                                                                  this.dataSoccerService = dataSoccerService;
                                                                                                                                                  this.teamRepository = teamRepository;
                                                                                                                                              }⎘
                                                                                                                                              Dans la méthode addTeam, ajoutez le code suivant :

                                                                                                                                              public void addTeam(TeamDTO team) {
                                                                                                                                                  Team entity = new Team(team.id(), team.name());
                                                                                                                                                  teamRepository.save(entity);
                                                                                                                                              }⎘
                                                                                                                                              La méthode addTeam crée une instance de l'entité Team à partir du DTO TeamDTO et l'ajoute à la base de données en utilisant le repository TeamRepository. La méthode save du repository TeamRepository permet d'ajouter une entité à la base de données. Notez que l'entité est mise à jour si elle existe déjà.

                                                                                                                                              Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que les équipes sont bien ajoutées à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                                                                                              Il reste à implémenter la méthode getTeams dans la classe JpaSoccerService. Ajoutez les deux méthodes suivantes à la classe JpaSoccerService :

                                                                                                                                              @Override
                                                                                                                                              public List<TeamDTO> getTeams() {
                                                                                                                                                  return teamRepository.findAll().stream()
                                                                                                                                                          .map(JpaSoccerService::toDTO)
                                                                                                                                                          .toList();
                                                                                                                                              }

                                                                                                                                              private static TeamDTO toDTO(Team team) {
                                                                                                                                                  return new TeamDTO(team.id, team.name);
                                                                                                                                              }⎘
                                                                                                                                              La méthode getTeams récupère toutes les équipes de la base de données en utilisant la méthode findAll du repository. Elle les convertit ensuite en DTO en utilisant la méthode toDTO. Cette conversion est effectuée grâce à la méthode map qui permet d'appliquer une fonction à chaque élément d'un stream. La notation :: permet de faire référence à une méthode. Dans notre, cas JpaSoccerService::toDTO fait référence à la méthode toDTO de la classe JpaSoccerService. La méthode map utilisera donc la méthode toDTO pour convertir chaque entité Team en un objet TeamDTO. La méthode toList permet de convertir le stream en une liste.

                                                                                                                                              Vous allez maintenant ajouter un test afin de vérifier que ce que vous venez d'implémenter fonctionne correctement. Dans la classe JpaSoccerServiceTest, ajoutez le test suivant et vérifiez qu'il passe :

                                                                                                                                              @Test
                                                                                                                                              void testGetTeams() {
                                                                                                                                                  // Given
                                                                                                                                                  List<TeamDTO> expectedTeams = dataSoccerService.getTeams();
                                                                                                                                                  // When
                                                                                                                                                  List<TeamDTO> teams = jpaSoccerService.getTeams();
                                                                                                                                                  // Then
                                                                                                                                                  assertThat(teams, containsInAnyOrder(expectedTeams.toArray()));
                                                                                                                                              }⎘
                                                                                                                                              Les imports nécessaires pour ce test sont les suivants :

                                                                                                                                              import static org.hamcrest.MatcherAssert.assertThat;
                                                                                                                                              import static org.hamcrest.Matchers.containsInAnyOrder;⎘
                                                                                                                                              3. Matchs
                                                                                                                                              Vous allez procéder de la même manière pour les matchs. Dans le fichier schema.sql, ajoutez la création de la table suivante en dessous de la création de la table teams :

                                                                                                                                              CREATE TABLE IF NOT EXISTS matches (
                                                                                                                                                  id UUID PRIMARY KEY,
                                                                                                                                                  home_team_id UUID NOT NULL,
                                                                                                                                                  away_team_id UUID NOT NULL,
                                                                                                                                                  home_team_goals INTEGER NOT NULL,
                                                                                                                                                  away_team_goals INTEGER NOT NULL,
                                                                                                                                                  date DATE NOT NULL,
                                                                                                                                                  time TIME NOT NULL,
                                                                                                                                                  FOREIGN KEY (home_team_id) REFERENCES teams(id),
                                                                                                                                                  FOREIGN KEY (away_team_id) REFERENCES teams(id),
                                                                                                                                                  CHECK (home_team_goals >= 0 AND away_team_goals >= 0),
                                                                                                                                                  CHECK (home_team_id != away_team_id),
                                                                                                                                                  UNIQUE (home_team_id, away_team_id)
                                                                                                                                              );⎘
                                                                                                                                              Vous remarquerez que la table matches contient des identifiants d'équipes. Ces identifiants correspondent à des équipes stockées dans la table teams. Des contraintes de clés étrangères sont ajoutées pour garantir que les identifiants d'équipes stockés dans la table matches correspondent à des équipes stockées dans la table teams. Des contraintes ont été également ajoutées pour garantir que les nombres de buts sont positifs et que les équipes à domicile et à l'extérieur sont différentes. Nous avons également ajouté une contrainte d'unicité pour garantir qu'un match ne peut être joué qu'une seule fois.

                                                                                                                                              Ajoutez maintenant une nouvelle entité Match dans le package com.project.entities :

                                                                                                                                              package com.project.entities;

                                                                                                                                              import java.time.LocalDate;
                                                                                                                                              import java.time.LocalTime;
                                                                                                                                              import java.util.UUID;

                                                                                                                                              import jakarta.persistence.Entity;
                                                                                                                                              import jakarta.persistence.Id;
                                                                                                                                              import jakarta.persistence.ManyToOne;
                                                                                                                                              import jakarta.persistence.Table;
                                                                                                                                              import jakarta.validation.constraints.NotNull;

                                                                                                                                              @Entity
                                                                                                                                              @Table(name = "matches")
                                                                                                                                              public class Match {
                                                                                                                                                  @Id
                                                                                                                                                  public UUID id;

                                                                                                                                                  @NotNull
                                                                                                                                                  @ManyToOne
                                                                                                                                                  public Team homeTeam;

                                                                                                                                                  @NotNull
                                                                                                                                                  @ManyToOne
                                                                                                                                                  public Team awayTeam;

                                                                                                                                                  @NotNull
                                                                                                                                                  public Integer homeTeamGoals;

                                                                                                                                                  @NotNull
                                                                                                                                                  public Integer awayTeamGoals;

                                                                                                                                                  @NotNull
                                                                                                                                                  public LocalDate date;

                                                                                                                                                  @NotNull
                                                                                                                                                  public  LocalTime time;

                                                                                                                                                  public Match() { }

                                                                                                                                                  public Match(UUID id, Team homeTeam, Team awayTeam,
                                                                                                                                                               Integer homeTeamGoals, Integer awayTeamGoals,
                                                                                                                                                               LocalDate date, LocalTime time) {
                                                                                                                                                      this.id = id;
                                                                                                                                                      this.homeTeam = homeTeam;
                                                                                                                                                      this.awayTeam = awayTeam;
                                                                                                                                                      this.homeTeamGoals = homeTeamGoals;
                                                                                                                                                      this.awayTeamGoals = awayTeamGoals;
                                                                                                                                                      this.date = date;
                                                                                                                                                      this.time = time;
                                                                                                                                                  }
                                                                                                                                              }⎘
                                                                                                                                              La nouveauté ici est l'utilisation de l'annotation @ManyToOne pour les attributs homeTeam et awayTeam. Cette annotation permet de spécifier une relation entre deux entités. Dans notre cas, un match a une équipe à domicile et une équipe à l'extérieur. L'annotation @ManyToOne indique que l'attribut homeTeam est une relation many-to-one avec l'entité Team. Cela signifie qu'une équipe peut jouer plusieurs matchs, mais qu'un match ne peut avoir qu'une seule équipe à domicile et une seule équipe à l'extérieur. Il existe d'autres annotations pour spécifier d'autres types de relations, comme @OneToMany, @OneToOne ou @ManyToMany. Vous remarquerez que le type des attributs homeTeam et awayTeam est Team et non UUID. En effet, l'annotation @ManyToOne permet de récupérer directement l'entité Team à partir de l'identifiant de l'équipe. Cela permet de simplifier les requêtes SQL et de récupérer directement les entités liées. La colonne de nom home_team_id (resp. away_team_id) dans la table matches est automatiquement liée à l'attribut homeTeam (resp. awayTeam) de l'entité Match. Ces liens sont réalisés grâce aux annotations et aux conventions de nommage.

                                                                                                                                              Ajoutez un repository nommé MatchRepository dans le package com.project.repositories :

                                                                                                                                              package com.project.repositories;

                                                                                                                                              import com.project.entities.Match;
                                                                                                                                              import org.springframework.data.jpa.repository.JpaRepository;
                                                                                                                                              import org.springframework.stereotype.Repository;
                                                                                                                                              import java.util.UUID;

                                                                                                                                              @Repository
                                                                                                                                              public interface MatchRepository extends JpaRepository<Match, UUID> { }⎘
                                                                                                                                              Comme pour ajouter un match, il n'est pas nécessaire de connaître les noms des équipes qui participent au match, vous allez définir un nouveau DTO pour fournir les informations nécessaires à la création d'un match. Ajoutez la classe MatchCreationDTO suivante dans le package com.project.dtos :

                                                                                                                                              public record MatchCreationDTO(
                                                                                                                                                  UUID id,
                                                                                                                                                  UUID homeTeamId,
                                                                                                                                                  UUID awayTeamId,
                                                                                                                                                  Integer homeTeamGoals,
                                                                                                                                                  Integer awayTeamGoals,
                                                                                                                                                  LocalDate date,
                                                                                                                                                  LocalTime time
                                                                                                                                              ) {
                                                                                                                                              }⎘
                                                                                                                                              À la fin de la méthode fillDatabase de la classe JpaSoccerService, ajoutez la ligne suivante :

                                                                                                                                              for (MatchDTO match : dataSoccerService.getMatches()) {
                                                                                                                                                  addMatch(new MatchCreationDTO(
                                                                                                                                                          match.id(),
                                                                                                                                                          match.homeTeam().id(), match.awayTeam().id(),
                                                                                                                                                          match.homeTeamGoals(), match.awayTeamGoals(),
                                                                                                                                                          match.date(), match.time()));
                                                                                                                                              }⎘
                                                                                                                                              Ajoutez ensuite la méthode addMatch :

                                                                                                                                              public void addMatch(MatchCreationDTO match) {
                                                                                                                                                  /* TODO */
                                                                                                                                              }⎘
                                                                                                                                              Injectez le repository MatchRepository dans la classe JpaSoccerService et essayez d'implémenter la méthode addMatch en utilisant Spring Data JPA. Pour créer l'entité, vous devez récupérer les entités Team correspondant aux équipes à domicile et à l'extérieur. Pour cela, vous pouvez utiliser la méthode findById du repository TeamRepository de la façon suivante :

                                                                                                                                              Team homeTeam = teamRepository.findById(match.homeTeamId()).orElseThrow();⎘
                                                                                                                                              La méthode findById est une méthode de l'interface JpaRepository qui permet de récupérer une entité à partir de son identifiant. Cette méthode retourne un Optional qui contient l'entité si elle existe. La méthode orElseThrow permet de lancer une exception si l'équipe n'existe pas, c'est-à-dire, si l'Optional est vide. Une fois l'instance de la classe Match créée, vous devez la sauvegarder dans repository MatchRepository en utilisant la méthode save. Exécutez l'application et vérifiez que les matchs sont bien ajoutés à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                                                                                              Il reste à implémenter la méthode getMatches dans la classe JpaSoccerService. Cette méthode doit retourner les matchs joués par une équipe. Les matchs doivent être triés par date et heure. Pour cela, ajoutez une nouvelle méthode dans le repository MatchRepository :

                                                                                                                                              List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                                                                                              Cette méthode permet de récupérer tous les matchs joués par une équipe à domicile ou à l'extérieur. Les matchs sont triés par date et heure. Notez que, si vous souhaitez récupérer la liste des matchs joués par une équipe d'identifiant teamId, il suffit d'appeler cette méthode de la façon suivante :

                                                                                                                                              List<Match> matches = matchRepository.findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(teamId, teamId);⎘
                                                                                                                                              Ajoutez la méthode suivante à la classe JpaSoccerService et complétez-la. Elle a pour but de convertir une entité Match en DTO MatchDTO.

                                                                                                                                              private static MatchDTO toDTO(Match match) {
                                                                                                                                                  return new MatchDTO(/* TODO */);
                                                                                                                                              }⎘
                                                                                                                                              Vous remarquerez qu'il est possible de récupérer l'identifiant et le nom des équipes à domicile et à l'extérieur en utilisant les attributs homeTeam et awayTeam de l'entité Match. Complétez ensuite la méthode getMatches en utilisant les méthodes précédemment définies.

                                                                                                                                              Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifier qu'il passe :

                                                                                                                                              @Test
                                                                                                                                              void testGetMatches() {
                                                                                                                                                  // Given
                                                                                                                                                  List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                                                                                                  UUID teamId = teams.get(4).id();
                                                                                                                                                  List<MatchDTO> expectedMatches = dataSoccerService.getMatches(teamId);
                                                                                                                                                  // When
                                                                                                                                                  List<MatchDTO> matches = jpaSoccerService.getMatches(teamId);
                                                                                                                                                  // Then
                                                                                                                                                  assertEquals(expectedMatches, matches);
                                                                                                                                              }⎘
                                                                                                                                              4. Calcul du classement
                                                                                                                                              Vous allez maintenant faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                                                                                              Dans un premier temps, vous allez modifier la création de la table ranking afin de supprimer le nom de l'équipe et d'ajouter la contrainte de clé étrangère. Modifiez la création de la table dans le script schema.sql de la façon suivante :

                                                                                                                                              CREATE TABLE IF NOT EXISTS ranking (
                                                                                                                                                  team_id UUID PRIMARY KEY,
                                                                                                                                                  rank INTEGER NOT NULL,
                                                                                                                                                  match_played_count INTEGER NOT NULL,
                                                                                                                                                  match_won_count INTEGER NOT NULL,
                                                                                                                                                  match_lost_count INTEGER NOT NULL,
                                                                                                                                                  draw_count INTEGER NOT NULL,
                                                                                                                                                  goal_for_count INTEGER NOT NULL,
                                                                                                                                                  goal_against_count INTEGER NOT NULL,
                                                                                                                                                  goal_difference INTEGER NOT NULL,
                                                                                                                                                  points INTEGER NOT NULL,
                                                                                                                                                  FOREIGN KEY (team_id) REFERENCES teams(id)
                                                                                                                                              );⎘
                                                                                                                                              Vous allez ensuite ajouter la nouvelle entité RankingRow suivante :

                                                                                                                                              @Entity
                                                                                                                                              @Table(name = "ranking")
                                                                                                                                              public class RankingRow {
                                                                                                                                                  @Id
                                                                                                                                                  public UUID teamId;

                                                                                                                                                  @OneToOne
                                                                                                                                                  @MapsId
                                                                                                                                                  public Team team;

                                                                                                                                                  public int rank;
                                                                                                                                                  public int matchPlayedCount;
                                                                                                                                                  public int matchWonCount;
                                                                                                                                                  public int matchLostCount;
                                                                                                                                                  public int drawCount;
                                                                                                                                                  public int goalForCount;
                                                                                                                                                  public int goalAgainstCount;
                                                                                                                                                  public int goalDifference;
                                                                                                                                                  public int points;

                                                                                                                                                  public RankingRow() {}

                                                                                                                                                  public RankingRow(Team team, int rank, int matchPlayedCount, int matchWonCount,
                                                                                                                                                                    int matchLostCount, int drawCount, int goalForCount,
                                                                                                                                                                    int goalAgainstCount, int goalDifference, int points) {
                                                                                                                                                      this.teamId = team.id;
                                                                                                                                                      this.team = team;
                                                                                                                                                      this.rank = rank;
                                                                                                                                                      this.matchPlayedCount = matchPlayedCount;
                                                                                                                                                      this.matchWonCount = matchWonCount;
                                                                                                                                                      this.matchLostCount = matchLostCount;
                                                                                                                                                      this.drawCount = drawCount;
                                                                                                                                                      this.goalForCount = goalForCount;
                                                                                                                                                      this.goalAgainstCount = goalAgainstCount;
                                                                                                                                                      this.goalDifference = goalDifference;
                                                                                                                                                      this.points = points;
                                                                                                                                                  }
                                                                                                                                              }⎘
                                                                                                                                              Une entité doit nécessairement avoir un identifiant. Il est donc nécessaire de définir l'attribut teamId et de l'annoter avec @Id. L'attribut team est nécessaire pour avoir accédé au nom de l'équipe. Il est annoté avec @OneToOne pour spécifier une relation one-to-one avec l'entité Team. L'annotation @MapsId permet de lier l'identifiant de RankingRow et l'identifiant utilisé pour la relation one-to-one.

                                                                                                                                              Ajoutez maintenant le repository RankingRepository dans le package com.project.repositories :

                                                                                                                                              @Repository
                                                                                                                                              public interface RankingRepository extends JpaRepository<RankingRow, UUID> {
                                                                                                                                              }⎘
                                                                                                                                              Dans la classe JpaSoccerService, injectez le repository RankingRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                                                                                              private final RankingRepository rankingRepository;⎘
                                                                                                                                              public JpaSoccerService(DataSoccerService dataSoccerService,
                                                                                                                                                              TeamRepository teamRepository,
                                                                                                                                                              MatchRepository matchRepository,
                                                                                                                                                              RankingRepository rankingRepository) {
                                                                                                                                                  this.dataSoccerService = dataSoccerService;
                                                                                                                                                  this.teamRepository = teamRepository;
                                                                                                                                                  this.matchRepository = matchRepository;
                                                                                                                                                  this.rankingRepository = rankingRepository;
                                                                                                                                              }⎘
                                                                                                                                              Au moment de l'ajout d'une équipe, vous allez devoir ajouter une ligne vide au classement. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser cette opération :

                                                                                                                                              private void addEmptyRankingRow(Team team) {
                                                                                                                                                  RankingRow entity = new RankingRow(team, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                                                                                                                                                  rankingRepository.save(entity);
                                                                                                                                              }⎘
                                                                                                                                              Modifiez la méthode addTeam pour qu'elle ajoute une ligne vide au classement associée à l'équipe ajoutée.

                                                                                                                                              Au moment de l'ajout d'un match, vous devez mettre à jour les deux lignes du classement correspondant aux équipes qui ont joué le match. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser la mise à jour d'une ligne du classement à partir de l'identifiant de l'équipe, du nombre de buts qu'elle a marqués et du nombre de buts qu'elle a encaissés :

                                                                                                                                              private void updateRankingRow(UUID teamId, int goalsForCount, int goalsAgainstCount) {
                                                                                                                                                  RankingRow entity = rankingRepository.findById(teamId).orElseThrow();
                                                                                                                                                  boolean win = goalsForCount > goalsAgainstCount;
                                                                                                                                                  boolean draw = goalsForCount == goalsAgainstCount;
                                                                                                                                                  boolean loss = goalsForCount < goalsAgainstCount;
                                                                                                                                                  entity.matchPlayedCount++;
                                                                                                                                                  entity.matchWonCount += win ? 1 : 0;
                                                                                                                                                  entity.drawCount += draw ? 1 : 0;
                                                                                                                                                  entity.matchLostCount += loss ? 1 : 0;
                                                                                                                                                  entity.goalForCount += goalsForCount;
                                                                                                                                                  entity.goalAgainstCount += goalsAgainstCount;
                                                                                                                                                  entity.goalDifference += goalsForCount - goalsAgainstCount;
                                                                                                                                                  entity.points += win ? 3 : draw ? 1 : 0;
                                                                                                                                                  rankingRepository.save(entity);
                                                                                                                                              }⎘
                                                                                                                                              Modifiez ensuite la méthode addMatch pour qu'elle mette à jour les lignes du classement correspondant aux équipes qui ont joué le match. Pour cela, ajoutez les deux lignes suivantes à la fin de la méthode addMatch :

                                                                                                                                              updateRankingRow(match.homeTeamId(), match.homeTeamGoals(), match.awayTeamGoals());
                                                                                                                                              updateRankingRow(match.awayTeamId(), match.awayTeamGoals(), match.homeTeamGoals());⎘
                                                                                                                                              Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que le classement est calculé en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console. Vous remarquerez que la colonne rank contient toujours des zéros, car nous n'avons pas encore fait en sorte qu'il soit recalculé après la modification du classement.

                                                                                                                                              Ajoutez la méthode suivante dans le repository RankingRepository :

                                                                                                                                              List<RankingRow> findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc();⎘
                                                                                                                                              Cette méthode permet d'obtenir les lignes du classement dans l'ordre du classement, c'est-à-dire, triées par points, différence de buts et nombre de buts marqués.

                                                                                                                                              Ajoutez ensuite la méthode suivante dans la classe JpaSoccerService pour recalculer le rang de chaque équipe :

                                                                                                                                              private void updateRanks() {
                                                                                                                                                  int rank = 1;
                                                                                                                                                  for (RankingRow row : rankingRepository.findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc()) {
                                                                                                                                                      row.rank = rank;
                                                                                                                                                      rankingRepository.save(row);
                                                                                                                                                      rank++;
                                                                                                                                                  }
                                                                                                                                              }⎘
                                                                                                                                              Cette méthode récupère toutes les lignes du classement triées par points, différence de buts et nombre de buts marqués. Elle met à jour le rang de chaque équipe en fonction de son classement. La méthode save du repository RankingRepository permet de mettre à jour la ligne du classement dans la base de données. Faites en sorte que la méthode updateRanks soit appelée après l'ajout d'une équipe ou d'un match. Supprimez une nouvelle fois la base de données, relancez l'application et vérifiez que les rangs des équipes ont été calculés.

                                                                                                                                              Il reste à implémenter les deux méthodes getRanking et getRankingRow dans la classe JpaSoccerService. Ajoutez la méthode suivante au repository RankingRepository de façon à obtenir le classement trié par rang :

                                                                                                                                              List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                              Ensuite, ajoutez la méthode suivante à la classe JpaSoccerService pour convertir les entités en DTO et complétez-la :

                                                                                                                                              private static RankingRowDTO toDTO(RankingRow rankingRow) {
                                                                                                                                                  return new RankingRowDTO(/* TODO */);
                                                                                                                                              }⎘
                                                                                                                                              Utilisez les méthodes définies précédemment pour implémenter la méthode getRanking. Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifiez qu'il passe :

                                                                                                                                              @Test
                                                                                                                                              void testGetRanking() {
                                                                                                                                                  // Given
                                                                                                                                                  List<RankingRowDTO> expectedRanking = dataSoccerService.getRanking();
                                                                                                                                                  // When
                                                                                                                                                  List<RankingRowDTO> ranking = jpaSoccerService.getRanking();
                                                                                                                                                  // Then
                                                                                                                                                  assertEquals(expectedRanking, ranking);
                                                                                                                                              }⎘
                                                                                                                                              L'alimentation actuelle de la base de données ne remplit plus directement la table ranking avec les informations du fichier ranking.json. Le contenu de la table est calculé à partir des équipes et des matchs. Le test vérifie que le classement présent dans la table ranking après l'alimentation de la base de données est égal au classement contenu dans le fichier ranking.json.

                                                                                                                                              Implémentez maintenant la méthode getRankingRow comme ceci :

                                                                                                                                              @Override
                                                                                                                                              public RankingRowDTO getRankingRow(UUID teamId) {
                                                                                                                                                  return rankingRepository.findById(teamId)
                                                                                                                                                          .map(JpaSoccerService::toDTO)
                                                                                                                                                          .orElseThrow();
                                                                                                                                              }⎘
                                                                                                                                              Ajoutez ensuite le test suivant et vérifiez qu'il passe :

                                                                                                                                              @Test
                                                                                                                                              void testGetRankingRow() {
                                                                                                                                                  // Given
                                                                                                                                                  List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                                                                                                  UUID teamId = teams.get(4).id();
                                                                                                                                                  RankingRowDTO expectedRankingRow = dataSoccerService.getRankingRow(teamId);
                                                                                                                                                  // When
                                                                                                                                                  RankingRowDTO rankingRow = jpaSoccerService.getRankingRow(teamId);
                                                                                                                                                  // Then
                                                                                                                                                  assertEquals(expectedRankingRow, rankingRow);
                                                                                                                                              }⎘
                                                                                                                                              Faites en sorte que le service JpaSoccerService soit utilisé par l'application en ajoutant l'annotation @Primary à la classe JpaSoccerService et en la supprimant à la classe DataSoccerService. Supprimez la base de données, puis lancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                                                                                              5. Transactions
                                                                                                                                              Les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService effectuent plusieurs opérations sur la base de données. Il est important que ces opérations soient effectuées de manière atomique. Pour cela, vous allez utiliser des transactions. Une transaction est un ensemble d'opérations effectuées de manière atomique. Si une des opérations échoue, toutes les opérations effectuées dans la transaction sont annulées. De plus, les requêtes ne pourront jamais voir les modifications effectuées durant la transaction tant que celle-ci n'est pas validée, c'est-à-dire, complètement réalisée.

                                                                                                                                              Dans le cas de Spring Data JPA, l'annotation @Transactional permet de spécifier que la méthode doit être exécutée dans une transaction. Ajoutez l'annotation @Transactional(isolation = Isolation.SERIALIZABLE) devant les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService. Relancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                                                                                              Le paramètre isolation permet de spécifier le niveau d'isolation de la transaction. Le niveau d'isolation SERIALIZABLE est le plus élevé. Normalement, ce niveau permet de simuler une exécution sérielle des transactions validées, comme si elles avaient été exécutées les unes après les autres séquentiellement. Le niveau d'isolation par défaut généralement est READ_COMMITTED. Avec ce niveau, les requêtes SELECT d'une transaction peuvent voir les données qui ont été commitées par les autres transactions. Ce niveau d'isolation n'est pas suffisant pour notre application. Par exemple, lors de l'ajout de deux matchs simultanément, il est possible que le classement ne soit pas mis à jour correctement. En effet, une même ligne peut être récupérée par deux transactions simultanées, puis mise à jour. Dans ce cas, la première transaction écrasera les modifications de la seconde transaction. Notez que la mise à jour des rangs peut également poser problème. Notez qu'en production, il est nécessaire d'utiliser un autre SGBD que H2 pour garantir la cohérence des données. H2 est un SGBD embarqué qui ne garantit pas une implémentation complète du niveau d'isolation SERIALIZABLE. Par conséquent, il est possible que des problèmes de concurrence surviennent lors de l'exécution de l'application.

                                                                                                                                              6. Optimisation des requêtes
                                                                                                                                              Cette section est facultative. Si vous n'avez pas le temps de la faire, vous pouvez passer directement au prochain TD. N'oubliez pas de commiter et de pusher votre code vers votre dépôt distant avant de passer au prochain TD.

                                                                                                                                              Vous allez faire en sorte de pouvoir visualiser les requêtes effectuées par l'application. Pour cela, replacez le contenu du fichier application.yml par le contenu suivant :

                                                                                                                                              server:
                                                                                                                                                error:
                                                                                                                                                  include-stacktrace: always
                                                                                                                                                  include-message: always
                                                                                                                                              spring:
                                                                                                                                                datasource:
                                                                                                                                                  url: jdbc:h2:file:./database
                                                                                                                                                  driverClassName: org.h2.Driver
                                                                                                                                                  username: sa
                                                                                                                                                  password:
                                                                                                                                                h2:
                                                                                                                                                  console:
                                                                                                                                                    enabled: true
                                                                                                                                                jpa:
                                                                                                                                                  show-sql: true
                                                                                                                                                sql:
                                                                                                                                                  init:
                                                                                                                                                    mode: always⎘
                                                                                                                                              Nous avons positionné la propriété spring.jpa.show-sql à true pour afficher les requêtes SQL effectuées par l'application. Lancez l'application et regardez les requêtes qui sont effectuées par l'application.

                                                                                                                                              Affichez le classement des équipes en utilisant l'application. Vous remarquerez qu'une première requête est effectuée pour récupérer le contenu de la table ranking. Ensuite, 20 requêtes sont effectuées sur la table teams pour récupérer le nom de l'équipe. Ces requêtes sont effectuées pour peupler les attributs team des entités RankingRow avec les noms des équipes. Ce problème est appelé le problème du n+1 selects.

                                                                                                                                              Pour éviter cela, il faudrait que la première requête contienne une jointure vers la table teams. Avec JPA, il est possible de préciser les requêtes qui seront effectuées par les appels aux méthodes des repositories en utilisant l'annotation @Query. Cette annotation permet de spécifier la requête SQL qui sera effectuée par la méthode. Plus précisément, vous devez fournir une requête JPQL (Java Persistence Query Language) qui est un langage de requête orienté objet. Par exemple, il est possible d'annoter la méthode findAllByOrderByRankAsc du repository RankingRepository avec l'annotation suivante :

                                                                                                                                              @Query("SELECT r FROM RankingRow r JOIN FETCH r.team ORDER BY r.rank ASC")
                                                                                                                                              List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                              Cette solution fonctionne, mais elle n'est pas optimale, car il est nécessaire d'écrire une requête JPQL dans le code de l'application. On perd l'avantage de Spring Data JPA qui permet de générer automatiquement les requêtes SQL à partir des noms des méthodes.

                                                                                                                                              Une autre solution consiste à utiliser des annotations @EntityGraph pour spécifier les entités qui doivent être chargées en même temps que l'entité principale. Par exemple, pour charger les noms des équipes en même temps que les lignes du classement, il est possible d'ajouter l'annotation @EntityGraph à la méthode du repository comme ceci :

                                                                                                                                              @EntityGraph(attributePaths = {"team"})
                                                                                                                                              List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                              Essayez d'ajouter cette annotation à la méthode findAllByOrderByRankAsc du repository RankingRepository. Relancez l'application et regardez les requêtes qui sont effectuées par l'application. Vous remarquerez que les noms des équipes sont maintenant récupérés en une seule requête.

                                                                                                                                              Quand la page de l'équipe est affichée, un appel à la méthode findById du repository RankingRepository est effectué pour récupérer la ligne du classement correspondant à l'équipe. Cette méthode est définie dans l'interface JpaRepository. Vous allez la redéfinir pour qu'elle effectue une jointure de la façon suivante :

                                                                                                                                              @EntityGraph(attributePaths = {"team"})
                                                                                                                                              @NonNull Optional<RankingRow> findById(@NonNull UUID teamId);⎘
                                                                                                                                              Regardez les requêtes qui sont effectuées au moment du chargement de la page d'une équipe. Le chargement des matchs nécessite actuellement de nombreuses requêtes pour obtenir les noms des équipes qui participent aux matchs. Pour corriger cela, dans le repository MatchRepository, ajoutez une annotation @EntityGraph à la méthode findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc pour récupérer les noms des équipes en même temps que les matchs :

                                                                                                                                              @EntityGraph(attributePaths = {"homeTeam", "awayTeam"})
                                                                                                                                              List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                                                                                              Relancez l'application et regardez à nouveau les requêtes qui sont effectuées par l'application. Le chargement du classement doit nécessiter une seule requête et le chargement de la page d'une équipe doit nécessiter deux requêtes : une pour récupérer la ligne du classement et une autre pour récupérer les matchs.

                                                                                                                                              Quand vous utilisez un ORM, il est toujours important de visualiser les requêtes qui sont effectuées par votre application. Cela permet de s'assurer que les requêtes sont optimales et de détecter les éventuels problèmes de performance.

                                                                                                                                              N'oubliez pas de faire un commit et de le pousser sur le dépôt distant.Vous allez implémenter la persistance des matchs et des équipes, puis le calcul automatique du classement.

                                                                                                                                                                                                                     Les étapes que vous allez devoir réaliser sont les suivantes :

                                                                                                                                                                                                                     Création d'un nouveau service pour interagir avec la base de données ;
                                                                                                                                                                                                                     Restructuration de la base de données pour stocker les équipes, les matchs et le classement ;
                                                                                                                                                                                                                     Utilisation de l'ORM de Spring Boot pour interagir avec la base de données ;
                                                                                                                                                                                                                     Mise en place de la mise à jour du classement après l'ajout d'une équipe ou d'un match ;
                                                                                                                                                                                                                     Alimentation de la base de données à partir des données statiques.
                                                                                                                                                                                                                     Vous allez devoir utiliser les concepts et technologies suivantes vus en cours :

                                                                                                                                                                                                                     Définir des entités avec Spring Data JPA ;
                                                                                                                                                                                                                     Définir des repositories avec Spring Data JPA ;
                                                                                                                                                                                                                     Ajouter des méthodes personnalisées aux repositories ;
                                                                                                                                                                                                                     Utilisation de Spring Data JPA pour effectuer des requêtes sur une base de données ;
                                                                                                                                                                                                                     Visualisation des requêtes SQL générées par Spring Data JPA et optimisation des requêtes.
                                                                                                                                                                                                                     1. Nouveau service
                                                                                                                                                                                                                     La structure actuelle de la base de données ne permet pas de stocker les matchs. Si nous ajoutons une table matches pour stocker les matchs, les noms des équipes seront à la fois présents dans la table ranking et dans la table matching. Cela pose un problème de redondance des données. Pour résoudre ce problème, il semble nécessaire d'ajouter une table teams pour lier les identifiants et les noms des équipes. La table ranking ne contiendra plus les noms des équipes, mais des identifiants qui correspondent à des équipes stockées dans la table teams. De même, la table matches contiendra uniquement des identifiants des équipes qui ont joué le match. Des jointures seront ensuite réalisées pour récupérer les noms des équipes.

                                                                                                                                                                                                                     Si la structure de la base de données évolue de cette manière, il ne semble plus pertinent d'utiliser uniquement JDBC pour interagir avec la base de données. Il semble que l'utilisation d'un ORM comme Spring Data JPA soit plus adaptée pour simplifier le développement. Cette évolution va nécessiter une modification assez conséquente de l'application. Heureusement, cette modification n'impacte que la couche d'accès aux données. Les autres composants de l'application restent inchangés.

                                                                                                                                                                                                                     Vérifiez que l'application actuelle utilise le service DataSoccerService. Ensuite, supprimez le service JdbcSoccerService et la classe de test associée. Lancez l'application et vérifiez qu'elle fonctionne. Créez ensuite un nouveau service nommé JpaSoccerService avec les méthodes suivantes :

                                                                                                                                                                                                                     @Service
                                                                                                                                                                                                                     public class JpaSoccerService implements SoccerService {
                                                                                                                                                                                                                         private final DataSoccerService dataSoccerService;

                                                                                                                                                                                                                         public JpaSoccerService(DataSoccerService dataSoccerService) {
                                                                                                                                                                                                                             this.dataSoccerService = dataSoccerService;
                                                                                                                                                                                                                         }

                                                                                                                                                                                                                         @EventListener
                                                                                                                                                                                                                         public void handleContextRefresh(ContextRefreshedEvent event) {
                                                                                                                                                                                                                             fillDatabase();
                                                                                                                                                                                                                         }

                                                                                                                                                                                                                         public void fillDatabase() {
                                                                                                                                                                                                                             if (!getRanking().isEmpty()) { return; }
                                                                                                                                                                                                                             /* TODO */
                                                                                                                                                                                                                         }

                                                                                                                                                                                                                         @Override
                                                                                                                                                                                                                         public List<RankingRowDTO> getRanking() {
                                                                                                                                                                                                                             /* TODO */
                                                                                                                                                                                                                             return List.of();
                                                                                                                                                                                                                         }

                                                                                                                                                                                                                         @Override
                                                                                                                                                                                                                         public RankingRowDTO getRankingRow(UUID teamId) {
                                                                                                                                                                                                                             /* TODO */
                                                                                                                                                                                                                             return null;
                                                                                                                                                                                                                         }

                                                                                                                                                                                                                         @Override
                                                                                                                                                                                                                         public List<MatchDTO> getMatches(UUID teamId) {
                                                                                                                                                                                                                             /* TODO */
                                                                                                                                                                                                                             return List.of();
                                                                                                                                                                                                                         }
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Ajoutez également une classe de test nommée JpaSoccerServiceTest :

                                                                                                                                                                                                                     @SpringBootTest
                                                                                                                                                                                                                     @ActiveProfiles("test")
                                                                                                                                                                                                                     @DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
                                                                                                                                                                                                                     public class JpaSoccerServiceTest {
                                                                                                                                                                                                                         @Autowired
                                                                                                                                                                                                                         private JpaSoccerService jpaSoccerService;

                                                                                                                                                                                                                         @Autowired
                                                                                                                                                                                                                         private DataSoccerService dataSoccerService;
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Le nouveau service sera implémenté de façon incrémentale. Dans un premier temps, vous allez faire persister les équipes, puis les matchs. Pour finir, vous allez faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                                                                                                                                                                     2. Équipes
                                                                                                                                                                                                                     Les données statiques des équipes sont stockées dans le fichier 'src/main/resources/data/teams.json'. Il contient un tableau d'objets JSON. Chaque objet contient un identifiant et un nom d'équipe comme le record TeamDTO.

                                                                                                                                                                                                                     Ajoutez la méthode suivante à l'interface SoccerService :

                                                                                                                                                                                                                     default List<TeamDTO> getTeams() {
                                                                                                                                                                                                                         return List.of();
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Dans la classe DataSoccerService, ajoutez la méthode suivante pour extraire les données du fichier teams.json :

                                                                                                                                                                                                                     @Override
                                                                                                                                                                                                                     public List<TeamDTO> getTeams() {
                                                                                                                                                                                                                         return getList("teams.json", TeamDTO.class);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     En haut du script schema.sql, ajoutez la création de la table suivante :

                                                                                                                                                                                                                     CREATE TABLE IF NOT EXISTS teams (
                                                                                                                                                                                                                         id UUID PRIMARY KEY,
                                                                                                                                                                                                                         name VARCHAR(255) NOT NULL
                                                                                                                                                                                                                     );⎘
                                                                                                                                                                                                                     Dans la classe JpaSoccerService, ajoutez la ligne suivante dans la méthode fillDatabase (en dessous du if):

                                                                                                                                                                                                                     for (TeamDTO team : dataSoccerService.getTeams()) addTeam(team);⎘
                                                                                                                                                                                                                     Ajoutez ensuite la méthode addTeam :

                                                                                                                                                                                                                     public void addTeam(TeamDTO team) {
                                                                                                                                                                                                                         /* TODO */
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     La méthode est publique, car il est probable que cette méthode soit utilisée par la suite pour ajouter de nouvelles équipes dans la base de données. Avant d'implémenter la méthode addTeam en utilisant Spring Data JPA, vous devez créer une entité Team qui correspond à la table teams. Une entité est une classe qui est en relation avec une table dans la base de données. Dans le package com.project.entities, ajoutez la classe Team suivante :

                                                                                                                                                                                                                     package com.project.entities;

                                                                                                                                                                                                                     import jakarta.persistence.Entity;
                                                                                                                                                                                                                     import jakarta.persistence.Table;
                                                                                                                                                                                                                     import jakarta.persistence.Id;
                                                                                                                                                                                                                     import jakarta.validation.constraints.NotNull;
                                                                                                                                                                                                                     import java.util.UUID;

                                                                                                                                                                                                                     @Entity
                                                                                                                                                                                                                     @Table(name = "teams")
                                                                                                                                                                                                                     public class Team {
                                                                                                                                                                                                                         @Id
                                                                                                                                                                                                                         public UUID id;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         public String name;

                                                                                                                                                                                                                         public Team() { }

                                                                                                                                                                                                                         public Team(UUID id, String name) {
                                                                                                                                                                                                                             this.id = id;
                                                                                                                                                                                                                             this.name = name;
                                                                                                                                                                                                                         }
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Une entité doit toujours avoir un constructeur sans paramètre. L'annotation @Entity indique que la classe Team est une entité. L'annotation @Table permet de spécifier le nom de la table dans la base de données. L'annotation @Id indique que l'attribut id est la clé primaire de la table. L'annotation @NotNull indique que l'attribut name ne peut pas être nul.

                                                                                                                                                                                                                     Ensuite, ajoutez un repository nommé TeamRepository dans le package com.project.repositories :

                                                                                                                                                                                                                     package com.project.repositories;

                                                                                                                                                                                                                     import com.project.entities.Team;
                                                                                                                                                                                                                     import org.springframework.data.jpa.repository.JpaRepository;
                                                                                                                                                                                                                     import org.springframework.stereotype.Repository;
                                                                                                                                                                                                                     import java.util.UUID;

                                                                                                                                                                                                                     @Repository
                                                                                                                                                                                                                     public interface TeamRepository extends JpaRepository<Team, UUID> { }⎘
                                                                                                                                                                                                                     Un repository va permettre d'effectuer des opérations en lien avec l'entité, comme ajouter, supprimer ou récupérer des entités. L'interface JpaRepository est une interface fournie par Spring Data JPA. L'annotation @Repository indique que la classe TeamRepository est un repository. Un repository peut être injecté dans un autre composant de l'application. Vous verrez par la suite qu'il est possible d'ajouter des méthodes à un repository pour effectuer des requêtes personnalisées.

                                                                                                                                                                                                                     Dans la classe JpaSoccerService, injectez le repository TeamRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                                                                                                                                                                     private final TeamRepository teamRepository;⎘
                                                                                                                                                                                                                     public JpaSoccerService(DataSoccerService dataSoccerService, TeamRepository teamRepository) {
                                                                                                                                                                                                                         this.dataSoccerService = dataSoccerService;
                                                                                                                                                                                                                         this.teamRepository = teamRepository;
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Dans la méthode addTeam, ajoutez le code suivant :

                                                                                                                                                                                                                     public void addTeam(TeamDTO team) {
                                                                                                                                                                                                                         Team entity = new Team(team.id(), team.name());
                                                                                                                                                                                                                         teamRepository.save(entity);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     La méthode addTeam crée une instance de l'entité Team à partir du DTO TeamDTO et l'ajoute à la base de données en utilisant le repository TeamRepository. La méthode save du repository TeamRepository permet d'ajouter une entité à la base de données. Notez que l'entité est mise à jour si elle existe déjà.

                                                                                                                                                                                                                     Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que les équipes sont bien ajoutées à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                                                                                                                                                                     Il reste à implémenter la méthode getTeams dans la classe JpaSoccerService. Ajoutez les deux méthodes suivantes à la classe JpaSoccerService :

                                                                                                                                                                                                                     @Override
                                                                                                                                                                                                                     public List<TeamDTO> getTeams() {
                                                                                                                                                                                                                         return teamRepository.findAll().stream()
                                                                                                                                                                                                                                 .map(JpaSoccerService::toDTO)
                                                                                                                                                                                                                                 .toList();
                                                                                                                                                                                                                     }

                                                                                                                                                                                                                     private static TeamDTO toDTO(Team team) {
                                                                                                                                                                                                                         return new TeamDTO(team.id, team.name);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     La méthode getTeams récupère toutes les équipes de la base de données en utilisant la méthode findAll du repository. Elle les convertit ensuite en DTO en utilisant la méthode toDTO. Cette conversion est effectuée grâce à la méthode map qui permet d'appliquer une fonction à chaque élément d'un stream. La notation :: permet de faire référence à une méthode. Dans notre, cas JpaSoccerService::toDTO fait référence à la méthode toDTO de la classe JpaSoccerService. La méthode map utilisera donc la méthode toDTO pour convertir chaque entité Team en un objet TeamDTO. La méthode toList permet de convertir le stream en une liste.

                                                                                                                                                                                                                     Vous allez maintenant ajouter un test afin de vérifier que ce que vous venez d'implémenter fonctionne correctement. Dans la classe JpaSoccerServiceTest, ajoutez le test suivant et vérifiez qu'il passe :

                                                                                                                                                                                                                     @Test
                                                                                                                                                                                                                     void testGetTeams() {
                                                                                                                                                                                                                         // Given
                                                                                                                                                                                                                         List<TeamDTO> expectedTeams = dataSoccerService.getTeams();
                                                                                                                                                                                                                         // When
                                                                                                                                                                                                                         List<TeamDTO> teams = jpaSoccerService.getTeams();
                                                                                                                                                                                                                         // Then
                                                                                                                                                                                                                         assertThat(teams, containsInAnyOrder(expectedTeams.toArray()));
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Les imports nécessaires pour ce test sont les suivants :

                                                                                                                                                                                                                     import static org.hamcrest.MatcherAssert.assertThat;
                                                                                                                                                                                                                     import static org.hamcrest.Matchers.containsInAnyOrder;⎘
                                                                                                                                                                                                                     3. Matchs
                                                                                                                                                                                                                     Vous allez procéder de la même manière pour les matchs. Dans le fichier schema.sql, ajoutez la création de la table suivante en dessous de la création de la table teams :

                                                                                                                                                                                                                     CREATE TABLE IF NOT EXISTS matches (
                                                                                                                                                                                                                         id UUID PRIMARY KEY,
                                                                                                                                                                                                                         home_team_id UUID NOT NULL,
                                                                                                                                                                                                                         away_team_id UUID NOT NULL,
                                                                                                                                                                                                                         home_team_goals INTEGER NOT NULL,
                                                                                                                                                                                                                         away_team_goals INTEGER NOT NULL,
                                                                                                                                                                                                                         date DATE NOT NULL,
                                                                                                                                                                                                                         time TIME NOT NULL,
                                                                                                                                                                                                                         FOREIGN KEY (home_team_id) REFERENCES teams(id),
                                                                                                                                                                                                                         FOREIGN KEY (away_team_id) REFERENCES teams(id),
                                                                                                                                                                                                                         CHECK (home_team_goals >= 0 AND away_team_goals >= 0),
                                                                                                                                                                                                                         CHECK (home_team_id != away_team_id),
                                                                                                                                                                                                                         UNIQUE (home_team_id, away_team_id)
                                                                                                                                                                                                                     );⎘
                                                                                                                                                                                                                     Vous remarquerez que la table matches contient des identifiants d'équipes. Ces identifiants correspondent à des équipes stockées dans la table teams. Des contraintes de clés étrangères sont ajoutées pour garantir que les identifiants d'équipes stockés dans la table matches correspondent à des équipes stockées dans la table teams. Des contraintes ont été également ajoutées pour garantir que les nombres de buts sont positifs et que les équipes à domicile et à l'extérieur sont différentes. Nous avons également ajouté une contrainte d'unicité pour garantir qu'un match ne peut être joué qu'une seule fois.

                                                                                                                                                                                                                     Ajoutez maintenant une nouvelle entité Match dans le package com.project.entities :

                                                                                                                                                                                                                     package com.project.entities;

                                                                                                                                                                                                                     import java.time.LocalDate;
                                                                                                                                                                                                                     import java.time.LocalTime;
                                                                                                                                                                                                                     import java.util.UUID;

                                                                                                                                                                                                                     import jakarta.persistence.Entity;
                                                                                                                                                                                                                     import jakarta.persistence.Id;
                                                                                                                                                                                                                     import jakarta.persistence.ManyToOne;
                                                                                                                                                                                                                     import jakarta.persistence.Table;
                                                                                                                                                                                                                     import jakarta.validation.constraints.NotNull;

                                                                                                                                                                                                                     @Entity
                                                                                                                                                                                                                     @Table(name = "matches")
                                                                                                                                                                                                                     public class Match {
                                                                                                                                                                                                                         @Id
                                                                                                                                                                                                                         public UUID id;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         @ManyToOne
                                                                                                                                                                                                                         public Team homeTeam;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         @ManyToOne
                                                                                                                                                                                                                         public Team awayTeam;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         public Integer homeTeamGoals;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         public Integer awayTeamGoals;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         public LocalDate date;

                                                                                                                                                                                                                         @NotNull
                                                                                                                                                                                                                         public  LocalTime time;

                                                                                                                                                                                                                         public Match() { }

                                                                                                                                                                                                                         public Match(UUID id, Team homeTeam, Team awayTeam,
                                                                                                                                                                                                                                      Integer homeTeamGoals, Integer awayTeamGoals,
                                                                                                                                                                                                                                      LocalDate date, LocalTime time) {
                                                                                                                                                                                                                             this.id = id;
                                                                                                                                                                                                                             this.homeTeam = homeTeam;
                                                                                                                                                                                                                             this.awayTeam = awayTeam;
                                                                                                                                                                                                                             this.homeTeamGoals = homeTeamGoals;
                                                                                                                                                                                                                             this.awayTeamGoals = awayTeamGoals;
                                                                                                                                                                                                                             this.date = date;
                                                                                                                                                                                                                             this.time = time;
                                                                                                                                                                                                                         }
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     La nouveauté ici est l'utilisation de l'annotation @ManyToOne pour les attributs homeTeam et awayTeam. Cette annotation permet de spécifier une relation entre deux entités. Dans notre cas, un match a une équipe à domicile et une équipe à l'extérieur. L'annotation @ManyToOne indique que l'attribut homeTeam est une relation many-to-one avec l'entité Team. Cela signifie qu'une équipe peut jouer plusieurs matchs, mais qu'un match ne peut avoir qu'une seule équipe à domicile et une seule équipe à l'extérieur. Il existe d'autres annotations pour spécifier d'autres types de relations, comme @OneToMany, @OneToOne ou @ManyToMany. Vous remarquerez que le type des attributs homeTeam et awayTeam est Team et non UUID. En effet, l'annotation @ManyToOne permet de récupérer directement l'entité Team à partir de l'identifiant de l'équipe. Cela permet de simplifier les requêtes SQL et de récupérer directement les entités liées. La colonne de nom home_team_id (resp. away_team_id) dans la table matches est automatiquement liée à l'attribut homeTeam (resp. awayTeam) de l'entité Match. Ces liens sont réalisés grâce aux annotations et aux conventions de nommage.

                                                                                                                                                                                                                     Ajoutez un repository nommé MatchRepository dans le package com.project.repositories :

                                                                                                                                                                                                                     package com.project.repositories;

                                                                                                                                                                                                                     import com.project.entities.Match;
                                                                                                                                                                                                                     import org.springframework.data.jpa.repository.JpaRepository;
                                                                                                                                                                                                                     import org.springframework.stereotype.Repository;
                                                                                                                                                                                                                     import java.util.UUID;

                                                                                                                                                                                                                     @Repository
                                                                                                                                                                                                                     public interface MatchRepository extends JpaRepository<Match, UUID> { }⎘
                                                                                                                                                                                                                     Comme pour ajouter un match, il n'est pas nécessaire de connaître les noms des équipes qui participent au match, vous allez définir un nouveau DTO pour fournir les informations nécessaires à la création d'un match. Ajoutez la classe MatchCreationDTO suivante dans le package com.project.dtos :

                                                                                                                                                                                                                     public record MatchCreationDTO(
                                                                                                                                                                                                                         UUID id,
                                                                                                                                                                                                                         UUID homeTeamId,
                                                                                                                                                                                                                         UUID awayTeamId,
                                                                                                                                                                                                                         Integer homeTeamGoals,
                                                                                                                                                                                                                         Integer awayTeamGoals,
                                                                                                                                                                                                                         LocalDate date,
                                                                                                                                                                                                                         LocalTime time
                                                                                                                                                                                                                     ) {
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     À la fin de la méthode fillDatabase de la classe JpaSoccerService, ajoutez la ligne suivante :

                                                                                                                                                                                                                     for (MatchDTO match : dataSoccerService.getMatches()) {
                                                                                                                                                                                                                         addMatch(new MatchCreationDTO(
                                                                                                                                                                                                                                 match.id(),
                                                                                                                                                                                                                                 match.homeTeam().id(), match.awayTeam().id(),
                                                                                                                                                                                                                                 match.homeTeamGoals(), match.awayTeamGoals(),
                                                                                                                                                                                                                                 match.date(), match.time()));
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Ajoutez ensuite la méthode addMatch :

                                                                                                                                                                                                                     public void addMatch(MatchCreationDTO match) {
                                                                                                                                                                                                                         /* TODO */
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Injectez le repository MatchRepository dans la classe JpaSoccerService et essayez d'implémenter la méthode addMatch en utilisant Spring Data JPA. Pour créer l'entité, vous devez récupérer les entités Team correspondant aux équipes à domicile et à l'extérieur. Pour cela, vous pouvez utiliser la méthode findById du repository TeamRepository de la façon suivante :

                                                                                                                                                                                                                     Team homeTeam = teamRepository.findById(match.homeTeamId()).orElseThrow();⎘
                                                                                                                                                                                                                     La méthode findById est une méthode de l'interface JpaRepository qui permet de récupérer une entité à partir de son identifiant. Cette méthode retourne un Optional qui contient l'entité si elle existe. La méthode orElseThrow permet de lancer une exception si l'équipe n'existe pas, c'est-à-dire, si l'Optional est vide. Une fois l'instance de la classe Match créée, vous devez la sauvegarder dans repository MatchRepository en utilisant la méthode save. Exécutez l'application et vérifiez que les matchs sont bien ajoutés à la base de données en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console.

                                                                                                                                                                                                                     Il reste à implémenter la méthode getMatches dans la classe JpaSoccerService. Cette méthode doit retourner les matchs joués par une équipe. Les matchs doivent être triés par date et heure. Pour cela, ajoutez une nouvelle méthode dans le repository MatchRepository :

                                                                                                                                                                                                                     List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                                                                                                                                                                     Cette méthode permet de récupérer tous les matchs joués par une équipe à domicile ou à l'extérieur. Les matchs sont triés par date et heure. Notez que, si vous souhaitez récupérer la liste des matchs joués par une équipe d'identifiant teamId, il suffit d'appeler cette méthode de la façon suivante :

                                                                                                                                                                                                                     List<Match> matches = matchRepository.findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(teamId, teamId);⎘
                                                                                                                                                                                                                     Ajoutez la méthode suivante à la classe JpaSoccerService et complétez-la. Elle a pour but de convertir une entité Match en DTO MatchDTO.

                                                                                                                                                                                                                     private static MatchDTO toDTO(Match match) {
                                                                                                                                                                                                                         return new MatchDTO(/* TODO */);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Vous remarquerez qu'il est possible de récupérer l'identifiant et le nom des équipes à domicile et à l'extérieur en utilisant les attributs homeTeam et awayTeam de l'entité Match. Complétez ensuite la méthode getMatches en utilisant les méthodes précédemment définies.

                                                                                                                                                                                                                     Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifier qu'il passe :

                                                                                                                                                                                                                     @Test
                                                                                                                                                                                                                     void testGetMatches() {
                                                                                                                                                                                                                         // Given
                                                                                                                                                                                                                         List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                                                                                                                                                                         UUID teamId = teams.get(4).id();
                                                                                                                                                                                                                         List<MatchDTO> expectedMatches = dataSoccerService.getMatches(teamId);
                                                                                                                                                                                                                         // When
                                                                                                                                                                                                                         List<MatchDTO> matches = jpaSoccerService.getMatches(teamId);
                                                                                                                                                                                                                         // Then
                                                                                                                                                                                                                         assertEquals(expectedMatches, matches);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     4. Calcul du classement
                                                                                                                                                                                                                     Vous allez maintenant faire en sorte que le classement soit mis à jour automatiquement après l'ajout d'une équipe ou d'un match.

                                                                                                                                                                                                                     Dans un premier temps, vous allez modifier la création de la table ranking afin de supprimer le nom de l'équipe et d'ajouter la contrainte de clé étrangère. Modifiez la création de la table dans le script schema.sql de la façon suivante :

                                                                                                                                                                                                                     CREATE TABLE IF NOT EXISTS ranking (
                                                                                                                                                                                                                         team_id UUID PRIMARY KEY,
                                                                                                                                                                                                                         rank INTEGER NOT NULL,
                                                                                                                                                                                                                         match_played_count INTEGER NOT NULL,
                                                                                                                                                                                                                         match_won_count INTEGER NOT NULL,
                                                                                                                                                                                                                         match_lost_count INTEGER NOT NULL,
                                                                                                                                                                                                                         draw_count INTEGER NOT NULL,
                                                                                                                                                                                                                         goal_for_count INTEGER NOT NULL,
                                                                                                                                                                                                                         goal_against_count INTEGER NOT NULL,
                                                                                                                                                                                                                         goal_difference INTEGER NOT NULL,
                                                                                                                                                                                                                         points INTEGER NOT NULL,
                                                                                                                                                                                                                         FOREIGN KEY (team_id) REFERENCES teams(id)
                                                                                                                                                                                                                     );⎘
                                                                                                                                                                                                                     Vous allez ensuite ajouter la nouvelle entité RankingRow suivante :

                                                                                                                                                                                                                     @Entity
                                                                                                                                                                                                                     @Table(name = "ranking")
                                                                                                                                                                                                                     public class RankingRow {
                                                                                                                                                                                                                         @Id
                                                                                                                                                                                                                         public UUID teamId;

                                                                                                                                                                                                                         @OneToOne
                                                                                                                                                                                                                         @MapsId
                                                                                                                                                                                                                         public Team team;

                                                                                                                                                                                                                         public int rank;
                                                                                                                                                                                                                         public int matchPlayedCount;
                                                                                                                                                                                                                         public int matchWonCount;
                                                                                                                                                                                                                         public int matchLostCount;
                                                                                                                                                                                                                         public int drawCount;
                                                                                                                                                                                                                         public int goalForCount;
                                                                                                                                                                                                                         public int goalAgainstCount;
                                                                                                                                                                                                                         public int goalDifference;
                                                                                                                                                                                                                         public int points;

                                                                                                                                                                                                                         public RankingRow() {}

                                                                                                                                                                                                                         public RankingRow(Team team, int rank, int matchPlayedCount, int matchWonCount,
                                                                                                                                                                                                                                           int matchLostCount, int drawCount, int goalForCount,
                                                                                                                                                                                                                                           int goalAgainstCount, int goalDifference, int points) {
                                                                                                                                                                                                                             this.teamId = team.id;
                                                                                                                                                                                                                             this.team = team;
                                                                                                                                                                                                                             this.rank = rank;
                                                                                                                                                                                                                             this.matchPlayedCount = matchPlayedCount;
                                                                                                                                                                                                                             this.matchWonCount = matchWonCount;
                                                                                                                                                                                                                             this.matchLostCount = matchLostCount;
                                                                                                                                                                                                                             this.drawCount = drawCount;
                                                                                                                                                                                                                             this.goalForCount = goalForCount;
                                                                                                                                                                                                                             this.goalAgainstCount = goalAgainstCount;
                                                                                                                                                                                                                             this.goalDifference = goalDifference;
                                                                                                                                                                                                                             this.points = points;
                                                                                                                                                                                                                         }
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Une entité doit nécessairement avoir un identifiant. Il est donc nécessaire de définir l'attribut teamId et de l'annoter avec @Id. L'attribut team est nécessaire pour avoir accédé au nom de l'équipe. Il est annoté avec @OneToOne pour spécifier une relation one-to-one avec l'entité Team. L'annotation @MapsId permet de lier l'identifiant de RankingRow et l'identifiant utilisé pour la relation one-to-one.

                                                                                                                                                                                                                     Ajoutez maintenant le repository RankingRepository dans le package com.project.repositories :

                                                                                                                                                                                                                     @Repository
                                                                                                                                                                                                                     public interface RankingRepository extends JpaRepository<RankingRow, UUID> {
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Dans la classe JpaSoccerService, injectez le repository RankingRepository en ajoutant la ligne suivante et en modifiant le constructeur :

                                                                                                                                                                                                                     private final RankingRepository rankingRepository;⎘
                                                                                                                                                                                                                     public JpaSoccerService(DataSoccerService dataSoccerService,
                                                                                                                                                                                                                                     TeamRepository teamRepository,
                                                                                                                                                                                                                                     MatchRepository matchRepository,
                                                                                                                                                                                                                                     RankingRepository rankingRepository) {
                                                                                                                                                                                                                         this.dataSoccerService = dataSoccerService;
                                                                                                                                                                                                                         this.teamRepository = teamRepository;
                                                                                                                                                                                                                         this.matchRepository = matchRepository;
                                                                                                                                                                                                                         this.rankingRepository = rankingRepository;
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Au moment de l'ajout d'une équipe, vous allez devoir ajouter une ligne vide au classement. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser cette opération :

                                                                                                                                                                                                                     private void addEmptyRankingRow(Team team) {
                                                                                                                                                                                                                         RankingRow entity = new RankingRow(team, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                                                                                                                                                                                                                         rankingRepository.save(entity);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Modifiez la méthode addTeam pour qu'elle ajoute une ligne vide au classement associée à l'équipe ajoutée.

                                                                                                                                                                                                                     Au moment de l'ajout d'un match, vous devez mettre à jour les deux lignes du classement correspondant aux équipes qui ont joué le match. Ajoutez la méthode suivante à la classe JpaSoccerService pour réaliser la mise à jour d'une ligne du classement à partir de l'identifiant de l'équipe, du nombre de buts qu'elle a marqués et du nombre de buts qu'elle a encaissés :

                                                                                                                                                                                                                     private void updateRankingRow(UUID teamId, int goalsForCount, int goalsAgainstCount) {
                                                                                                                                                                                                                         RankingRow entity = rankingRepository.findById(teamId).orElseThrow();
                                                                                                                                                                                                                         boolean win = goalsForCount > goalsAgainstCount;
                                                                                                                                                                                                                         boolean draw = goalsForCount == goalsAgainstCount;
                                                                                                                                                                                                                         boolean loss = goalsForCount < goalsAgainstCount;
                                                                                                                                                                                                                         entity.matchPlayedCount++;
                                                                                                                                                                                                                         entity.matchWonCount += win ? 1 : 0;
                                                                                                                                                                                                                         entity.drawCount += draw ? 1 : 0;
                                                                                                                                                                                                                         entity.matchLostCount += loss ? 1 : 0;
                                                                                                                                                                                                                         entity.goalForCount += goalsForCount;
                                                                                                                                                                                                                         entity.goalAgainstCount += goalsAgainstCount;
                                                                                                                                                                                                                         entity.goalDifference += goalsForCount - goalsAgainstCount;
                                                                                                                                                                                                                         entity.points += win ? 3 : draw ? 1 : 0;
                                                                                                                                                                                                                         rankingRepository.save(entity);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Modifiez ensuite la méthode addMatch pour qu'elle mette à jour les lignes du classement correspondant aux équipes qui ont joué le match. Pour cela, ajoutez les deux lignes suivantes à la fin de la méthode addMatch :

                                                                                                                                                                                                                     updateRankingRow(match.homeTeamId(), match.homeTeamGoals(), match.awayTeamGoals());
                                                                                                                                                                                                                     updateRankingRow(match.awayTeamId(), match.awayTeamGoals(), match.homeTeamGoals());⎘
                                                                                                                                                                                                                     Supprimez le fichier database.mv.db à la racine du projet pour supprimer la base de données H2. Lancez l'application et vérifiez que le classement est calculé en utilisant la console H2 accessible à l'adresse http://localhost:8080/h2-console. Vous remarquerez que la colonne rank contient toujours des zéros, car nous n'avons pas encore fait en sorte qu'il soit recalculé après la modification du classement.

                                                                                                                                                                                                                     Ajoutez la méthode suivante dans le repository RankingRepository :

                                                                                                                                                                                                                     List<RankingRow> findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc();⎘
                                                                                                                                                                                                                     Cette méthode permet d'obtenir les lignes du classement dans l'ordre du classement, c'est-à-dire, triées par points, différence de buts et nombre de buts marqués.

                                                                                                                                                                                                                     Ajoutez ensuite la méthode suivante dans la classe JpaSoccerService pour recalculer le rang de chaque équipe :

                                                                                                                                                                                                                     private void updateRanks() {
                                                                                                                                                                                                                         int rank = 1;
                                                                                                                                                                                                                         for (RankingRow row : rankingRepository.findAllByOrderByPointsDescGoalDifferenceDescGoalForCountDesc()) {
                                                                                                                                                                                                                             row.rank = rank;
                                                                                                                                                                                                                             rankingRepository.save(row);
                                                                                                                                                                                                                             rank++;
                                                                                                                                                                                                                         }
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Cette méthode récupère toutes les lignes du classement triées par points, différence de buts et nombre de buts marqués. Elle met à jour le rang de chaque équipe en fonction de son classement. La méthode save du repository RankingRepository permet de mettre à jour la ligne du classement dans la base de données. Faites en sorte que la méthode updateRanks soit appelée après l'ajout d'une équipe ou d'un match. Supprimez une nouvelle fois la base de données, relancez l'application et vérifiez que les rangs des équipes ont été calculés.

                                                                                                                                                                                                                     Il reste à implémenter les deux méthodes getRanking et getRankingRow dans la classe JpaSoccerService. Ajoutez la méthode suivante au repository RankingRepository de façon à obtenir le classement trié par rang :

                                                                                                                                                                                                                     List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                                                                                                     Ensuite, ajoutez la méthode suivante à la classe JpaSoccerService pour convertir les entités en DTO et complétez-la :

                                                                                                                                                                                                                     private static RankingRowDTO toDTO(RankingRow rankingRow) {
                                                                                                                                                                                                                         return new RankingRowDTO(/* TODO */);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Utilisez les méthodes définies précédemment pour implémenter la méthode getRanking. Ajoutez ensuite le test suivant dans la classe JpaSoccerServiceTest et vérifiez qu'il passe :

                                                                                                                                                                                                                     @Test
                                                                                                                                                                                                                     void testGetRanking() {
                                                                                                                                                                                                                         // Given
                                                                                                                                                                                                                         List<RankingRowDTO> expectedRanking = dataSoccerService.getRanking();
                                                                                                                                                                                                                         // When
                                                                                                                                                                                                                         List<RankingRowDTO> ranking = jpaSoccerService.getRanking();
                                                                                                                                                                                                                         // Then
                                                                                                                                                                                                                         assertEquals(expectedRanking, ranking);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     L'alimentation actuelle de la base de données ne remplit plus directement la table ranking avec les informations du fichier ranking.json. Le contenu de la table est calculé à partir des équipes et des matchs. Le test vérifie que le classement présent dans la table ranking après l'alimentation de la base de données est égal au classement contenu dans le fichier ranking.json.

                                                                                                                                                                                                                     Implémentez maintenant la méthode getRankingRow comme ceci :

                                                                                                                                                                                                                     @Override
                                                                                                                                                                                                                     public RankingRowDTO getRankingRow(UUID teamId) {
                                                                                                                                                                                                                         return rankingRepository.findById(teamId)
                                                                                                                                                                                                                                 .map(JpaSoccerService::toDTO)
                                                                                                                                                                                                                                 .orElseThrow();
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Ajoutez ensuite le test suivant et vérifiez qu'il passe :

                                                                                                                                                                                                                     @Test
                                                                                                                                                                                                                     void testGetRankingRow() {
                                                                                                                                                                                                                         // Given
                                                                                                                                                                                                                         List<TeamDTO> teams = dataSoccerService.getTeams();
                                                                                                                                                                                                                         UUID teamId = teams.get(4).id();
                                                                                                                                                                                                                         RankingRowDTO expectedRankingRow = dataSoccerService.getRankingRow(teamId);
                                                                                                                                                                                                                         // When
                                                                                                                                                                                                                         RankingRowDTO rankingRow = jpaSoccerService.getRankingRow(teamId);
                                                                                                                                                                                                                         // Then
                                                                                                                                                                                                                         assertEquals(expectedRankingRow, rankingRow);
                                                                                                                                                                                                                     }⎘
                                                                                                                                                                                                                     Faites en sorte que le service JpaSoccerService soit utilisé par l'application en ajoutant l'annotation @Primary à la classe JpaSoccerService et en la supprimant à la classe DataSoccerService. Supprimez la base de données, puis lancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                                                                                                                                                                     5. Transactions
                                                                                                                                                                                                                     Les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService effectuent plusieurs opérations sur la base de données. Il est important que ces opérations soient effectuées de manière atomique. Pour cela, vous allez utiliser des transactions. Une transaction est un ensemble d'opérations effectuées de manière atomique. Si une des opérations échoue, toutes les opérations effectuées dans la transaction sont annulées. De plus, les requêtes ne pourront jamais voir les modifications effectuées durant la transaction tant que celle-ci n'est pas validée, c'est-à-dire, complètement réalisée.

                                                                                                                                                                                                                     Dans le cas de Spring Data JPA, l'annotation @Transactional permet de spécifier que la méthode doit être exécutée dans une transaction. Ajoutez l'annotation @Transactional(isolation = Isolation.SERIALIZABLE) devant les méthodes fillDatabase, addTeam et addMatch de la classe JpaSoccerService. Relancez l'application et vérifiez qu'elle fonctionne correctement.

                                                                                                                                                                                                                     Le paramètre isolation permet de spécifier le niveau d'isolation de la transaction. Le niveau d'isolation SERIALIZABLE est le plus élevé. Normalement, ce niveau permet de simuler une exécution sérielle des transactions validées, comme si elles avaient été exécutées les unes après les autres séquentiellement. Le niveau d'isolation par défaut généralement est READ_COMMITTED. Avec ce niveau, les requêtes SELECT d'une transaction peuvent voir les données qui ont été commitées par les autres transactions. Ce niveau d'isolation n'est pas suffisant pour notre application. Par exemple, lors de l'ajout de deux matchs simultanément, il est possible que le classement ne soit pas mis à jour correctement. En effet, une même ligne peut être récupérée par deux transactions simultanées, puis mise à jour. Dans ce cas, la première transaction écrasera les modifications de la seconde transaction. Notez que la mise à jour des rangs peut également poser problème. Notez qu'en production, il est nécessaire d'utiliser un autre SGBD que H2 pour garantir la cohérence des données. H2 est un SGBD embarqué qui ne garantit pas une implémentation complète du niveau d'isolation SERIALIZABLE. Par conséquent, il est possible que des problèmes de concurrence surviennent lors de l'exécution de l'application.

                                                                                                                                                                                                                     6. Optimisation des requêtes
                                                                                                                                                                                                                     Cette section est facultative. Si vous n'avez pas le temps de la faire, vous pouvez passer directement au prochain TD. N'oubliez pas de commiter et de pusher votre code vers votre dépôt distant avant de passer au prochain TD.

                                                                                                                                                                                                                     Vous allez faire en sorte de pouvoir visualiser les requêtes effectuées par l'application. Pour cela, replacez le contenu du fichier application.yml par le contenu suivant :

                                                                                                                                                                                                                     server:
                                                                                                                                                                                                                       error:
                                                                                                                                                                                                                         include-stacktrace: always
                                                                                                                                                                                                                         include-message: always
                                                                                                                                                                                                                     spring:
                                                                                                                                                                                                                       datasource:
                                                                                                                                                                                                                         url: jdbc:h2:file:./database
                                                                                                                                                                                                                         driverClassName: org.h2.Driver
                                                                                                                                                                                                                         username: sa
                                                                                                                                                                                                                         password:
                                                                                                                                                                                                                       h2:
                                                                                                                                                                                                                         console:
                                                                                                                                                                                                                           enabled: true
                                                                                                                                                                                                                       jpa:
                                                                                                                                                                                                                         show-sql: true
                                                                                                                                                                                                                       sql:
                                                                                                                                                                                                                         init:
                                                                                                                                                                                                                           mode: always⎘
                                                                                                                                                                                                                     Nous avons positionné la propriété spring.jpa.show-sql à true pour afficher les requêtes SQL effectuées par l'application. Lancez l'application et regardez les requêtes qui sont effectuées par l'application.

                                                                                                                                                                                                                     Affichez le classement des équipes en utilisant l'application. Vous remarquerez qu'une première requête est effectuée pour récupérer le contenu de la table ranking. Ensuite, 20 requêtes sont effectuées sur la table teams pour récupérer le nom de l'équipe. Ces requêtes sont effectuées pour peupler les attributs team des entités RankingRow avec les noms des équipes. Ce problème est appelé le problème du n+1 selects.

                                                                                                                                                                                                                     Pour éviter cela, il faudrait que la première requête contienne une jointure vers la table teams. Avec JPA, il est possible de préciser les requêtes qui seront effectuées par les appels aux méthodes des repositories en utilisant l'annotation @Query. Cette annotation permet de spécifier la requête SQL qui sera effectuée par la méthode. Plus précisément, vous devez fournir une requête JPQL (Java Persistence Query Language) qui est un langage de requête orienté objet. Par exemple, il est possible d'annoter la méthode findAllByOrderByRankAsc du repository RankingRepository avec l'annotation suivante :

                                                                                                                                                                                                                     @Query("SELECT r FROM RankingRow r JOIN FETCH r.team ORDER BY r.rank ASC")
                                                                                                                                                                                                                     List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                                                                                                     Cette solution fonctionne, mais elle n'est pas optimale, car il est nécessaire d'écrire une requête JPQL dans le code de l'application. On perd l'avantage de Spring Data JPA qui permet de générer automatiquement les requêtes SQL à partir des noms des méthodes.

                                                                                                                                                                                                                     Une autre solution consiste à utiliser des annotations @EntityGraph pour spécifier les entités qui doivent être chargées en même temps que l'entité principale. Par exemple, pour charger les noms des équipes en même temps que les lignes du classement, il est possible d'ajouter l'annotation @EntityGraph à la méthode du repository comme ceci :

                                                                                                                                                                                                                     @EntityGraph(attributePaths = {"team"})
                                                                                                                                                                                                                     List<RankingRow> findAllByOrderByRankAsc();⎘
                                                                                                                                                                                                                     Essayez d'ajouter cette annotation à la méthode findAllByOrderByRankAsc du repository RankingRepository. Relancez l'application et regardez les requêtes qui sont effectuées par l'application. Vous remarquerez que les noms des équipes sont maintenant récupérés en une seule requête.

                                                                                                                                                                                                                     Quand la page de l'équipe est affichée, un appel à la méthode findById du repository RankingRepository est effectué pour récupérer la ligne du classement correspondant à l'équipe. Cette méthode est définie dans l'interface JpaRepository. Vous allez la redéfinir pour qu'elle effectue une jointure de la façon suivante :

                                                                                                                                                                                                                     @EntityGraph(attributePaths = {"team"})
                                                                                                                                                                                                                     @NonNull Optional<RankingRow> findById(@NonNull UUID teamId);⎘
                                                                                                                                                                                                                     Regardez les requêtes qui sont effectuées au moment du chargement de la page d'une équipe. Le chargement des matchs nécessite actuellement de nombreuses requêtes pour obtenir les noms des équipes qui participent aux matchs. Pour corriger cela, dans le repository MatchRepository, ajoutez une annotation @EntityGraph à la méthode findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc pour récupérer les noms des équipes en même temps que les matchs :

                                                                                                                                                                                                                     @EntityGraph(attributePaths = {"homeTeam", "awayTeam"})
                                                                                                                                                                                                                     List<Match> findAllByHomeTeamIdOrAwayTeamIdOrderByDateAscTimeAsc(UUID homeTeamId, UUID awayTeamId);⎘
                                                                                                                                                                                                                     Relancez l'application et regardez à nouveau les requêtes qui sont effectuées par l'application. Le chargement du classement doit nécessiter une seule requête et le chargement de la page d'une équipe doit nécessiter deux requêtes : une pour récupérer la ligne du classement et une autre pour récupérer les matchs.

                                                                                                                                                                                                                     Quand vous utilisez un ORM, il est toujours important de visualiser les requêtes qui sont effectuées par votre application. Cela permet de s'assurer que les requêtes sont optimales et de détecter les éventuels problèmes de performance.

                                                                                                                                                                                                                     N'oubliez pas de faire un commit et de le pousser sur le dépôt distant.